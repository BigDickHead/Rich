
mawk - pattern scanning and text processing language

SYNOPSIS
       mawk [-W option] [-F value] [-v var=value] [--] 'program text' [file ...]
       mawk [-W option] [-F value] [-v var=value] [-f program-file] [--] [file ...]

DESCRIPTION
       mawk  is  an interpreter for the AWK Programming Language.  The AWK language is useful for manipulation of data files,
       text retrieval and processing, and for prototyping and experimenting with algorithms.  mawk is a new  awk  meaning  it
       implements  the AWK language as defined in Aho, Kernighan and Weinberger, The AWK Programming Language, Addison-Wesley
       Publishing, 1988.  (Hereafter referred to as the AWK book.)  mawk conforms to the Posix 1003.2 (draft 11.3) definition
       of  the AWK language which contains a few features not described in the AWK book,  and mawk provides a small number of
       extensions.

       An AWK program is a sequence of pattern {action} pairs and function definitions.  Short programs are  entered  on  the
       command  line  usually enclosed in ' ' to avoid shell interpretation.  Longer programs can be read in from a file with
       the -f option.  Data  input is read from the list of files on the command line or from standard input when the list is
       empty.  The input is broken into records as determined by the record separator variable, RS.  Initially, RS = "\n" and
       records are synonymous with lines.  Each record is compared against each pattern and if it matches, the  program  text
       for {action} is executed.

OPTIONS
       -F value       sets the field separator, FS, to value.

       -f file        Program text is read from file instead of from the command line.  Multiple -f options are allowed.

       -v var=value   assigns value to program variable var.

       --             indicates the unambiguous end of options.

       The  above  options  will  be  available  with any Posix compatible implementation of AWK, and implementation specific
       options are prefaced with -W.  mawk provides six:

       -W version     mawk writes its version and copyright to stdout and compiled limits to stderr and exits 0.

       -W dump        writes an assembler like listing of the internal representation of the program to stdout  and  exits  0
                      (on successful compilation).

       -W interactive sets  unbuffered  writes  to  stdout  and line buffered reads from stdin.  Records from stdin are lines
                      regardless of the value of RS.

       -W exec file   Program text is read from file and this is the last option. Useful  on  systems  that  support  the  #!
                      "magic number" convention for executable scripts.

       -W sprintf=num adjusts  the  size  of  mawk's internal sprintf buffer to num bytes.  More than rare use of this option
                      indicates mawk should be recompiled.

       -W posix_space forces mawk not to consider '\n' to be space.

       The short forms -W[vdiesp] are recognized and on some systems -We is mandatory to avoid command  line  length  limita‐
       tions.

THE AWK LANGUAGE
   1. Program structure
       An AWK program is a sequence of pattern {action} pairs and user function definitions.

       A pattern can be:
              BEGIN
              END
              expression
              expression , expression

       One,  but  not both, of pattern {action} can be omitted.   If {action} is omitted it is implicitly { print }.  If pat‐
       tern is omitted, then it is implicitly matched.  BEGIN and END patterns require an action.

       Statements are terminated by newlines, semi-colons or both.  Groups of statements such as actions or loop  bodies  are
       blocked  via  { ... } as in C.  The last statement in a block doesn't need a terminator.  Blank lines have no meaning;
       an empty statement is terminated with a semi-colon. Long statements can be continued with a backslash, \.  A statement
       can  be  broken without a backslash after a comma, left brace, &&, ||, do, else, the right parenthesis of an if, while
       or for statement, and the right parenthesis of a function definition.  A comment starts with #  and  extends  to,  but
       does not include the end of line.

       The following statements control program flow inside blocks.

              if ( expr ) statement

              if ( expr ) statement else statement

              while ( expr ) statement

              do statement while ( expr )

              for ( opt_expr ; opt_expr ; opt_expr ) statement

              for ( var in array ) statement

              continue

              break

   2. Data types, conversion and comparison
       There  are  two basic data types, numeric and string.  Numeric constants can be integer like -2, decimal like 1.08, or
       in scientific notation like -1.1e4 or .28E-3.  All numbers are represented internally and all computations are done in
       floating point arithmetic.  So for example, the expression 0.2e2 == 20 is true and true is represented as 1.0.

       String constants are enclosed in double quotes.

                                          "This is a string with a newline at the end.\n"

       Strings can be continued across a line by escaping (\) the newline.  The following escape sequences are recognized.

            \\        \
            \"        "
            \a        alert, ascii 7
            \b        backspace, ascii 8
            \t        tab, ascii 9
            \n        newline, ascii 10
            \v        vertical tab, ascii 11
            \f        formfeed, ascii 12
            \r        carriage return, ascii 13
            \ddd      1, 2 or 3 octal digits for ascii ddd
            \xhh      1 or 2 hex digits for ascii  hh

       If you escape any other character \c, you get \c, i.e., mawk ignores the escape.

       There  are  really  three basic data types; the third is number and string which has both a numeric value and a string
       value at the same time.  User defined variables come into existence when first referenced and are initialized to null,
       a  number  and  string  value which has numeric value 0 and string value "".  Non-trivial number and string typed data
       come from input and are typically stored in fields.  (See section 4).

       The type of an expression is determined by its context and automatic type conversion occurs if needed.   For  example,
       to evaluate the statements

            y = x + 2  ;  z = x  "hello"

       The  value  stored  in  variable  y will be typed numeric.  If x is not numeric, the value read from x is converted to
       numeric before it is added to 2 and stored in y.  The value stored in variable z will be typed string, and  the  value
       of x will be converted to string if necessary and concatenated with "hello".  (Of course, the value and type stored in
       x is not changed by any conversions.)  A string expression is converted to numeric using its longest numeric prefix as
       with  atof(3).  A numeric expression is converted to string by replacing expr with sprintf(CONVFMT, expr), unless expr
       can be represented on the host machine as an exact integer then it is converted to sprintf("%d", expr).  Sprintf()  is
       an  AWK built-in that duplicates the functionality of sprintf(3), and CONVFMT is a built-in variable used for internal
       conversion from number to string and initialized to "%.6g".  Explicit type conversions  can  be  forced,  expr  ""  is
       string and expr+0 is numeric.

       To  evaluate, expr1 rel-op expr2, if both operands are numeric or number and string then the comparison is numeric; if
       both operands are string the comparison is string; if one operand is string, the non-string operand is  converted  and
       the comparison is string.  The result is numeric, 1 or 0.

       In  boolean  contexts  such as, if ( expr ) statement, a string expression evaluates true if and only if it is not the
       empty string ""; numeric values if and only if not numerically zero.

   3. Regular expressions
       In the AWK language, records, fields and strings are often tested for matching a regular expression.  Regular  expres‐
       sions are enclosed in slashes, and

            expr ~ /r/

       is an AWK expression that evaluates to 1 if expr "matches" r, which means a substring of expr is in the set of strings
       defined by r.  With no match the expression evaluates to 0; replacing ~ with the "not match" operator, !~  ,  reverses
       the meaning.  As  pattern-action pairs,

            /r/ { action }   and   $0 ~ /r/ { action }

       are the same, and for each input record that matches r, action is executed.  In fact, /r/ is an AWK expression that is
       equivalent to ($0 ~ /r/) anywhere except when on the right side of a match operator or passed  as  an  argument  to  a
       built-in function that expects a regular expression argument.

       AWK  uses extended regular expressions as with egrep(1).  The regular expression metacharacters, i.e., those with spe‐
       cial meaning in regular expressions are

             ^ $ . [ ] | ( ) * + ?

       Regular expressions are built up from characters as follows:

              c            matches any non-metacharacter c.

              \c           matches a character defined by the same escape sequences used in string constants or  the  literal
                           character c if \c is not an escape sequence.

              .            matches any character (including newline).

              ^            matches the front of a string.

              $            matches the back of a string.

              [c1c2c3...]  matches  any character in the class c1c2c3... .  An interval of characters is denoted c1-c2 inside
                           a class [...].

              [^c1c2c3...] matches any character not in the class c1c2c3...

       Regular expressions are built up from other regular expressions as follows:

              r1r2         matches r1 followed immediately by r2 (concatenation).

              r1 | r2      matches r1 or r2 (alternation).

              r*           matches r repeated zero or more times.

              r+           matches r repeated one or more times.

              r?           matches r zero or once.

              (r)          matches r, providing grouping.

       The increasing precedence of operators is alternation, concatenation and unary (*, + or ?).

       For example,

            /^[_a-zA-Z][_a-zA-Z0-9]*$/  and
            /^[-+]?([0-9]+\.?|\.[0-9])[0-9]*([eE][-+]?[0-9]+)?$/

       are matched by AWK identifiers and AWK numeric constants respectively.  Note that . has to be escaped to be recognized
       as a decimal point, and that metacharacters are not special inside character classes.

       Any expression can be used on the right hand side of the ~ or !~ operators or passed to a built-in that expects a reg‐
       ular expression.  If needed, it is converted to string, and then interpreted as a regular expression.  For example,

            BEGIN { identifier = "[_a-zA-Z][_a-zA-Z0-9]*" }

            $0 ~ "^" identifier

       prints all lines that start with an AWK identifier.

       mawk recognizes the empty regular expression, //, which matches the empty string and hence is matched by any string at
       the front, back and between every character.  For example,

            echo  abc | mawk { gsub(//, "X") ; print }
            XaXbXcX


   4. Records and fields
       Records  are  read  in  one at a time, and stored in the field variable $0.  The record is split into fields which are
       stored in $1, $2, ..., $NF.  The built-in variable NF is set to the number of fields, and NR and FNR  are  incremented
       by 1.  Fields above $NF are set to "".

       Assignment  to  $0  causes  the fields and NF to be recomputed.  Assignment to NF or to a field causes $0 to be recon‐
       structed by concatenating the $i's separated by OFS.  Assignment to a field with index greater than NF,  increases  NF
       and causes $0 to be reconstructed.

       Data  input  stored  in  fields  is  string,  unless the entire field has numeric form and then the type is number and
       string.  For example,

            echo 24 24E |
            mawk '{ print($1>100, $1>"100", $2>100, $2>"100") }'
            0 1 1 1

       $0 and $2 are string and $1 is number and string.  The first comparison is numeric, the second is string, the third is
       string (100 is converted to "100"), and the last is string.

   5. Expressions and operators
       The  expression  syntax  is  similar  to  C.   Primary expressions are numeric constants, string constants, variables,
       fields, arrays and function calls.  The identifier for a variable, array or function can be  a  sequence  of  letters,
       digits  and  underscores,  that does not start with a digit.  Variables are not declared; they exist when first refer‐
       enced and are initialized to null.

       New expressions are composed with the following operators in order of increasing precedence.

              assignment          =  +=  -=  *=  /=  %=  ^=
              conditional         ?  :
              logical or          ||
              logical and         &&
              array membership    in
              matching       ~   !~
              relational          <  >   <=  >=  ==  !=
              concatenation       (no explicit operator)
              add ops             +  -
              mul ops             *  /  %
              unary               +  -
              logical not         !
              exponentiation      ^
              inc and dec         ++ -- (both post and pre)
              field               $

       Assignment, conditional and exponentiation associate right to left; the other operators associate left to right.   Any
       expression can be parenthesized.

   6. Arrays
       Awk  provides  one-dimensional  arrays.  Array elements are expressed as array[expr].  Expr is internally converted to
       string type, so, for example, A[1] and A["1"] are the same element and the actual index is  "1".   Arrays  indexed  by
       strings  are  called associative arrays.  Initially an array is empty; elements exist when first accessed.  An expres‐
       sion, expr in array evaluates to 1 if array[expr] exists, else to 0.

       There is a form of the for statement that loops over each index of an array.

            for ( var in array ) statement

       sets var to each index of array and executes statement.  The order that var transverses the indices of  array  is  not
       defined.

       The  statement,  delete array[expr], causes array[expr] not to exist.  mawk supports an extension, delete array, which
       deletes all elements of array.

       Multidimensional arrays are synthesized with concatenation using the built-in variable SUBSEP.  array[expr1,expr2]  is
       equivalent to array[expr1 SUBSEP expr2].  Testing for a multidimensional element uses a parenthesized index, such as

            if ( (i, j) in A )  print A[i, j]


   7. Builtin-variables
       The following variables are built-in and initialized before program execution.

              ARGC      number of command line arguments.

              ARGV      array of command line arguments, 0..ARGC-1.

              CONVFMT   format for internal conversion of numbers to string, initially = "%.6g".

              ENVIRON   array indexed by environment variables.  An environment string, var=value is stored as ENVIRON[var] =
                        value.

              FILENAME  name of the current input file.

              FNR       current record number in FILENAME.

              FS        splits records into fields as a regular expression.

              NF        number of fields in the current record.

              NR        current record number in the total input stream.

              OFMT      format for printing numbers; initially = "%.6g".

              OFS       inserted between fields on output, initially = " ".

              ORS       terminates each record on output, initially = "\n".

              RLENGTH   length set by the last call to the built-in function, match().

              RS        input record separator, initially = "\n".

              RSTART    index set by the last call to match().

              SUBSEP    used to build multiple array subscripts, initially = "\034".

   8. Built-in functions
       String functions

              gsub(r,s,t)  gsub(r,s)
                     Global substitution, every match of regular expression r in variable t is replaced  by  string  s.   The
                     number  of  replacements is returned.  If t is omitted, $0 is used.  An & in the replacement string s is
                     replaced by the matched substring of t.  \& and \\ put  literal & and \, respectively, in  the  replace‐
                     ment string.

              index(s,t)
                     If  t  is a substring of s, then the position where t starts is returned, else 0 is returned.  The first
                     character of s is in position 1.

              length(s)
                     Returns the length of string s.

              match(s,r)
                     Returns the index of the first longest match of regular expression r in  string  s.   Returns  0  if  no
                     match.   As a side effect, RSTART is set to the return value.  RLENGTH is set to the length of the match
                     or -1 if no match.  If the empty string is matched, RLENGTH is set to 0, and 1 is returned if the  match
                     is at the front, and length(s)+1 is returned if the match is at the back.

              split(s,A,r)  split(s,A)
                     String  s is split into fields by regular expression r and the fields are loaded into array A.  The num‐
                     ber of fields is returned.  See section 11 below for more detail.  If r is omitted, FS is used.

              sprintf(format,expr-list)
                     Returns a string constructed from expr-list according to format.  See the description of printf() below.

              sub(r,s,t)  sub(r,s)
                     Single substitution, same as gsub() except at most one substitution.

              substr(s,i,n)  substr(s,i)
                     Returns the substring of string s, starting at index i, of length n.  If n is omitted, the suffix of  s,
                     starting at i is returned.

              tolower(s)
                     Returns a copy of s with all upper case characters converted to lower case.

              toupper(s)
                     Returns a copy of s with all lower case characters converted to upper case.

       Arithmetic functions

              atan2(y,x)     Arctan of y/x between -pi and pi.

              cos(x)         Cosine function, x in radians.

              exp(x)         Exponential function.

              int(x)         Returns x truncated towards zero.

              log(x)         Natural logarithm.

              rand()         Returns a random number between zero and one.

              sin(x)         Sine function, x in radians.

              sqrt(x)        Returns square root of x.

              srand(expr)  srand()
                     Seeds the random number generator, using the clock if expr is omitted, and returns the value of the pre‐
                     vious seed.  mawk seeds the random number generator from the clock at startup so there is no  real  need
                     to call srand().  Srand(expr) is useful for repeating pseudo random sequences.

   9. Input and output
       There are two output statements, print and printf.

              print  writes $0  ORS to standard output.

              print expr1, expr2, ..., exprn
                     writes  expr1  OFS  expr2  OFS  ...  exprn ORS to standard output.  Numeric expressions are converted to
                     string with OFMT.

              printf format, expr-list
                     duplicates the printf C library function writing to standard output.  The complete ANSI C format  speci‐
                     fications are recognized with conversions %c, %d, %e, %E, %f, %g, %G, %i, %o, %s, %u, %x, %X and %%, and
                     conversion qualifiers h and l.

       The argument list to print or printf can optionally be enclosed in parentheses.  Print formats numbers using  OFMT  or
       "%d"  for  exact integers.  "%c" with a numeric argument prints the corresponding 8 bit character, with a string argu‐
       ment it prints the first character of the string.  The output of print and printf can be redirected to a file or  com‐
       mand  by  appending > file, >> file or | command to the end of the print statement.  Redirection opens file or command
       only once, subsequent redirections append to the already open stream.  By convention,  mawk  associates  the  filename
       "/dev/stderr"  with  stderr  which  allows  print and printf to be redirected to stderr.  mawk also associates "-" and
       "/dev/stdout" with stdin and stdout which allows these streams to be passed to functions.

       The input function getline has the following variations.

              getline
                     reads into $0, updates the fields, NF, NR and FNR.

              getline < file
                     reads into $0 from file, updates the fields and NF.

              getline var
                     reads the next record into var, updates NR and FNR.

              getline var < file
                     reads the next record of file into var.

               command | getline
                     pipes a record from command into $0 and updates the fields and NF.

               command | getline var
                     pipes a record from command into var.

       Getline returns 0 on end-of-file, -1 on error, otherwise 1.

       Commands on the end of pipes are executed by /bin/sh.

       The function close(expr) closes the file or pipe associated with expr.  Close returns 0 if expr is an open  file,  the
       exit  status  if  expr is a piped command, and -1 otherwise.  Close is used to reread a file or command, make sure the
       other end of an output pipe is finished or conserve file resources.

       The function fflush(expr) flushes the output file or pipe associated with expr.  Fflush returns 0 if expr is  an  open
       output  stream  else  -1.   Fflush without an argument flushes stdout.  Fflush with an empty argument ("") flushes all
       open output.

       The function system(expr) uses /bin/sh to execute expr and returns the exit status of the command expr.  Changes  made
       to the ENVIRON array are not passed to commands executed with system or pipes.

   10. User defined functions
       The syntax for a user defined function is

            function name( args ) { statements }

       The function body can contain a return statement

            return opt_expr

       A  return  statement is not required.  Function calls may be nested or recursive.  Functions are passed expressions by
       value and arrays by reference.  Extra arguments serve as local variables and are initialized to  null.   For  example,
       csplit(s,A) puts each character of s into array A and returns the length of s.

            function csplit(s, A,    n, i)
            {
              n = length(s)
              for( i = 1 ; i <= n ; i++ ) A[i] = substr(s, i, 1)
              return n
            }

       Putting  extra space between passed arguments and local variables is conventional.  Functions can be referenced before
       they are defined, but the function name and the '(' of the arguments must touch to avoid confusion with concatenation.

   11. Splitting strings, records and files
       Awk programs use the same algorithm to split strings into arrays with split(), and records into fields  on  FS.   mawk
       uses essentially the same algorithm to split files into records on RS.

       Split(expr,A,sep) works as follows:

              (1)    If  sep  is omitted, it is replaced by FS.  Sep can be an expression or regular expression.  If it is an
                     expression of non-string type, it is converted to string.

              (2)    If sep = " " (a single space), then <SPACE> is trimmed from the front and back of expr, and sep  becomes
                     <SPACE>.  mawk defines <SPACE> as the regular expression /[ \t\n]+/.  Otherwise sep is treated as a reg‐
                     ular expression, except that meta-characters are ignored for a string of length  1,  e.g.,  split(x,  A,
                     "*") and split(x, A, /\*/) are the same.

              (3)    If  expr is not string, it is converted to string.  If expr is then the empty string "", split() returns
                     0 and A is set empty.  Otherwise, all non-overlapping, non-null and longest matches of sep in expr, sep‐
                     arate  expr  into  fields  which  are loaded into A.  The fields are placed in A[1], A[2], ..., A[n] and
                     split() returns n, the number of fields which is the number of matches plus one.  Data placed in A  that
                     looks numeric is typed number and string.

       Splitting records into fields works the same except the pieces are loaded into $1, $2,..., $NF.  If $0 is empty, NF is
       set to 0 and all $i to "".

       mawk splits files into records by the same algorithm, but with the slight difference that RS is  really  a  terminator
       instead of a separator.  (ORS is really a terminator too).

              E.g.,  if  FS  =  ":+" and $0 = "a::b:" , then NF = 3 and $1 = "a", $2 = "b" and $3 = "", but if "a::b:" is the
              contents of an input file and RS = ":+", then there are two records "a" and "b".

       RS = " " is not special.

       If FS = "", then mawk breaks the record into individual characters, and, similarly, split(s,A,"") places the  individ‐
       ual characters of s into A.

   12. Multi-line records
       Since  mawk  interprets  RS  as a regular expression, multi-line records are easy.  Setting RS = "\n\n+", makes one or
       more blank lines separate records.  If FS = " " (the default), then single newlines, by the rules for  <SPACE>  above,
       become space and single newlines are field separators.

              For example, if a file is "a b\nc\n\n", RS = "\n\n+" and FS = " ", then there is one record "a b\nc" with three
              fields "a", "b" and "c".  Changing FS = "\n", gives two fields "a b" and "c"; changing FS = "", gives one field
              identical to the record.

       If  you want lines with spaces or tabs to be considered blank, set RS = "\n([ \t]*\n)+".  For compatibility with other
       awks, setting RS = "" has the same effect as if blank lines are stripped from the front and back  of  files  and  then
       records  are determined as if RS = "\n\n+".  Posix requires that "\n" always separates records when RS = "" regardless
       of the value of FS.  mawk does not support this convention, because defining "\n" as <SPACE> makes it unnecessary.

       Most of the time when you change RS for multi-line records, you will also want to change ORS to "\n\n" so  the  record
       spacing is preserved on output.

   13. Program execution
       This  section  describes  the order of program execution.  First ARGC is set to the total number of command line argu‐
       ments passed to the execution phase of the program.  ARGV[0] is set the name of the AWK interpreter  and  ARGV[1]  ...
       ARGV[ARGC-1] holds the remaining command line arguments exclusive of options and program source.  For example with

            mawk  -f  prog  v=1  A  t=hello  B

       ARGC = 5 with ARGV[0] = "mawk", ARGV[1] = "v=1", ARGV[2] = "A", ARGV[3] = "t=hello" and ARGV[4] = "B".

       Next,  each BEGIN block is executed in order.  If the program consists entirely of BEGIN blocks, then execution termi‐
       nates, else an input stream is opened and execution continues.  If ARGC equals 1, the input stream is  set  to  stdin,
       else  the command line arguments ARGV[1] ...  ARGV[ARGC-1] are examined for a file argument.

       The  command  line  arguments  divide  into three sets: file arguments, assignment arguments and empty strings "".  An
       assignment has the form var=string.  When an ARGV[i] is examined as a possible file argument, if it  is  empty  it  is
       skipped;  if  it  is  an assignment argument, the assignment to var takes place and i skips to the next argument; else
       ARGV[i] is opened for input.  If it fails to open, execution terminates with exit code 2.  If no command line argument
       is  a  file  argument,  then  input  comes from stdin.  Getline in a BEGIN action opens input.  "-" as a file argument
       denotes stdin.

       Once an input stream is open, each input record is tested against each pattern, and  if  it  matches,  the  associated
       action  is executed.  An expression pattern matches if it is boolean true (see the end of section 2).  A BEGIN pattern
       matches before any input has been read, and an END pattern matches after all input has been read.   A  range  pattern,
       expr1,expr2 , matches every record between the match of expr1 and the match expr2 inclusively.

       When  end  of  file occurs on the input stream, the remaining command line arguments are examined for a file argument,
       and if there is one it is opened, else the END pattern is considered matched and all END actions are executed.

       In the example, the assignment v=1 takes place after the BEGIN actions are executed, and the data placed in v is typed
       number and string.  Input is then read from file A.  On end of file A, t is set to the string "hello", and B is opened
       for input.  On end of file B, the END actions are executed.

       Program flow at the pattern {action} level can be changed with the

            next
            exit  opt_expr

       statements.  A next statement causes the next input record to be read and pattern testing to restart  with  the  first
       pattern {action} pair in the program.  An exit statement causes immediate execution of the END actions or program ter‐
       mination if there are none or if the exit occurs in an END action.  The opt_expr sets the exit value  of  the  program
       unless overridden by a later exit or subsequent error.

EXAMPLES
       1. emulate cat.

            { print }

       2. emulate wc.

            { chars += length($0) + 1  # add one for the \n
              words += NF
            }

            END{ print NR, words, chars }

       3. count the number of unique "real words".

            BEGIN { FS = "[^A-Za-z]+" }

            { for(i = 1 ; i <= NF ; i++)  word[$i] = "" }

            END { delete word[""]
                  for ( i in word )  cnt++
                  print cnt
            }

       4. sum the second field of every record based on the first field.

            $1 ~ /credit|gain/ { sum += $2 }
            $1 ~ /debit|loss/  { sum -= $2 }

            END { print sum }

       5. sort a file, comparing as string

            { line[NR] = $0 "" }  # make sure of comparison type
                            # in case some lines look numeric

            END {  isort(line, NR)
              for(i = 1 ; i <= NR ; i++) print line[i]
            }

            #insertion sort of A[1..n]
            function isort( A, n,    i, j, hold)
            {
              for( i = 2 ; i <= n ; i++)
              {
                hold = A[j = i]
                while ( A[j-1] > hold )
                { j-- ; A[j+1] = A[j] }
                A[j] = hold
              }
              # sentinel A[0] = "" will be created if needed
            }


COMPATIBILITY ISSUES
       The  Posix 1003.2(draft 11.3) definition of the AWK language is AWK as described in the AWK book with a few extensions
       that appeared in SystemVR4 nawk. The extensions are:

              New functions: toupper() and tolower().

              New variables: ENVIRON[] and CONVFMT.

              ANSI C conversion specifications for printf() and sprintf().

              New command options:  -v var=value, multiple -f options and implementation options as arguments to -W.


       Posix AWK is oriented to operate on files a line at a time.  RS can be changed from "\n" to another single  character,
       but it is hard to find any use for this — there are no examples in the AWK book.  By convention, RS = "", makes one or
       more blank lines separate records, allowing multi-line records.  When RS =  "",  "\n"  is  always  a  field  separator
       regardless of the value in FS.

       mawk,  on the other hand, allows RS to be a regular expression.  When "\n" appears in records, it is treated as space,
       and FS always determines fields.

       Removing the line at a time paradigm can make some programs simpler and can often improve performance.   For  example,
       redoing example 3 from above,

            BEGIN { RS = "[^A-Za-z]+" }

            { word[ $0 ] = "" }

            END { delete  word[ "" ]
              for( i in word )  cnt++
              print cnt
            }

       counts  the number of unique words by making each word a record.  On moderate size files, mawk executes twice as fast,
       because of the simplified inner loop.

       The following program replaces each comment by a single space in a C program file,

            BEGIN {
              RS = "/\*([^*]|\*+[^/*])*\*+/"
                 # comment is record separator
              ORS = " "
              getline  hold
              }

              { print hold ; hold = $0 }

              END { printf "%s" , hold }

       Buffering one record is needed to avoid terminating the last record with a space.

       With mawk, the following are all equivalent,

            x ~ /a\+b/    x ~ "a\+b"     x ~ "a\\+b"

       The strings get scanned twice, once as string and once as regular expression.  On the string scan,  mawk  ignores  the
       escape  on  non-escape  characters  while  the  AWK book advocates \c be recognized as c which necessitates the double
       escaping of meta-characters in strings.  Posix explicitly declines to define the behavior which passively forces  pro‐
       grams that must run under a variety of awks to use the more portable but less readable, double escape.

       Posix  AWK  does  not recognize "/dev/std{out,err}" or \x hex escape sequences in strings.  Unlike ANSI C, mawk limits
       the number of digits that follows \x to two as the current implementation only supports 8 bit characters.  The  built-
       in  fflush  first  appeared  in  a  recent  (1993) AT&T awk released to netlib, and is not part of the posix standard.
       Aggregate deletion with delete array is not part of the posix standard.

       Posix explicitly leaves the behavior of FS = "" undefined, and mentions splitting the record into characters as a pos‐
       sible interpretation, but currently this use is not portable across implementations.

       Finally, here is how mawk handles exceptional cases not discussed in the AWK book or the Posix draft.  It is unsafe to
       assume consistency across awks and safe to skip to the next section.

              substr(s, i, n) returns the characters of s in the intersection of the closed interval [1, length(s)]  and  the
              half-open  interval  [i, i+n).  When this intersection is empty, the empty string is returned; so substr("ABC",
              1, 0) = "" and substr("ABC", -4, 6) = "A".

              Every string, including the empty string, matches the empty string at the front so, s ~ //  and  s  ~  "",  are
              always 1 as is match(s, //) and match(s, "").  The last two set RLENGTH to 0.

              index(s,  t)  is  always the same as match(s, t1) where t1 is the same as t with metacharacters escaped.  Hence
              consistency with match requires that index(s, "") always returns 1.  Also the condition, index(s,t) != 0 if and
              only t is a substring of s, requires index("","") = 1.

              If  getline encounters end of file, getline var, leaves var unchanged.  Similarly, on entry to the END actions,
              $0, the fields and NF have their value unaltered from the last record.

SEE ALSO
       egrep(1)

       Aho, Kernighan and Weinberger, The AWK Programming Language, Addison-Wesley Publishing, 1988, (the AWK book),  defines
       the  language,  opening  with a tutorial and advancing to many interesting programs that delve into issues of software
       design and analysis relevant to programming in any language.

       The GAWK Manual, The Free Software Foundation, 1991, is a tutorial and language reference that does  not  attempt  the
       depth  of the AWK book and assumes the reader may be a novice programmer.  The section on AWK arrays is excellent.  It
       also discusses Posix requirements for AWK.

================================================================================================================
#!/bin/bash
VER=`java -version 2>&1 | grep "java version" | awk '{print $3}' | tr -d \" | awk '{split($0, array, ".")} END{print array[2]}'`
if [[ $VER -ge 6 ]]; then
    echo " >= 1.6"
else
    echo " <= 1.6"
fi
================================================================================================================

    
第一个 awk

$ awk '{ print }' /etc/passwd

您将会见到 /etc/passwd 文件的内容出现在眼前。现在，解释 awk 做了些什么。调用 awk 时，我们指定 /etc/passwd 作为输入文件。执行 awk 时，它依次对 /etc/passwd 中的每一行执行 print 命令。所有输出都发送到 stdout，所得到的结果与与执行catting /etc/passwd完全相同。

现在，解释 { print } 代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。

这里是另一个 awk 示例，它的作用与上例完全相同：

$ awk '{ print $0 }' /etc/passwd

在 awk 中，$0 变量表示整个当前行，所以 print 和 print $0 的作用完全一样。

如果您愿意，可以创建一个 awk 程序，让它输出与输入数据完全无关的数据。以下是一个示例：

$ awk '{ print "" }' /etc/passwd

只要将 "" 字符串传递给 print 命令，它就会打印空白行。如果测试该脚本，将会发现对于 /etc/passwd 文件中的每一行，awk 都输出一个空白行。再次说明， awk 对输入文件中的每一行都执行这个脚本。以下是另一个示例：

$ awk '{ print "hiya" }' /etc/passwd

运行这个脚本将在您的屏幕上写满 hiya。:)

多个字段
awk 非常善于处理分成多个逻辑字段的文本，而且让您可以毫不费力地引用 awk 脚本中每个独立的字段。以下脚本将打印出您的系统上所有用户帐户的列表：

$ awk -F":" '{ print $1 }' /etc/passwd

上例中，在调用 awk 时，使用 -F 选项来指定 ":" 作为字段分隔符。awk 处理 print $1 命令时，它会打印出在输入文件中每一行中出现的第一个字段。以下是另一个示例：

$ awk -F":" '{ print $1 $3 }' /etc/passwd

以下是该脚本输出的摘录：

halt7
operator11
root0
shutdown6
sync5
bin1
....etc.

如您所见，awk 打印出 /etc/passwd 文件的第一和第三个字段，它们正好分别是用户名和用户标识字段。现在，当脚本运行时，它并不理想 -- 在两个输出字段之间没有空格！如果习惯于使用 bash 或 python 进行编程，那么您会指望 print $1 $3 命令在两个字段之间插入空格。然而，当两个字符串在 awk 程序中彼此相邻时，awk 会连接它们但不在它们之间添加空格。以下命令会在这两个字段中插入空格：

$ awk -F":" '{ print $1 " " $3 }' /etc/passwd

以这种方式调用 print 时，它将连接 $1、" " 和 $3，创建可读的输出。当然，如果需要的话，我们还可以插入一些文本标签：

$ awk -F":" '{ print "username: " $1 "\t\tuid:" $3" }' /etc/passwd

这将产生以下输出：

username: halt          uid:7
username: operator      uid:11
username: root          uid:0
username: shutdown      uid:6
username: sync          uid:5
username: bin           uid:1
....etc.

外部脚本
将脚本作为命令行自变量传递给 awk 对于小的单行程序来说是非常简单的，而对于多行程序，它就比较复杂。您肯定想要在外部文件中撰写脚本。然后可以向 awk 传递 -f 选项，以向它提供此脚本文件：

$ awk -f myscript.awk myfile.in

将脚本放入文本文件还可以让您使用附加 awk 功能。例如，这个多行脚本与前面的单行脚本的作用相同，它们都打印出 /etc/passwd 中每一行的第一个字段：

BEGIN {
    FS=":"
}

{ print $1 }

这两个方法的差别在于如何设置字段分隔符。在这个脚本中，字段分隔符在代码自身中指定（通过设置 FS 变量），而在前一个示例中，通过在命令行上向 awk 传递 -F":" 选项来设置 FS。通常，最好在脚本自身中设置字段分隔符，只是因为这表示您可以少输入一个命令行自变量。我们将在本文的后面详细讨论 FS 变量。

BEGIN 和 END 块
通常，对于每个输入行，awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之前执行初始化代码。对于这种情况，awk 允许您定义一个 BEGIN 块。我们在前一个示例中使用了 BEGIN 块。因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。

awk 还提供了另一个特殊块，叫作 END 块。awk 在处理了输入文件中的所有行之后执行这个块。通常，END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。

规则表达式和块
awk 允许使用规则表达式，根据规则表达式是否匹配当前行来选择执行独立代码块。以下示例脚本只输出包含字符序列 foo 的那些行：

/foo/ { print }

当然，可以使用更复杂的规则表达式。以下脚本将只打印包含浮点数的行：

/[0-9]+\.[0-9]*/ { print }

表达式和块
还有许多其它方法可以选择执行代码块。我们可以将任意一种布尔表达式放在一个代码块之前，以控制何时执行某特定块。仅当对前面的布尔表达式求值为真时，awk 才执行代码块。以下示例脚本输出将输出其第一个字段等于 fred 的所有行中的第三个字段。如果当前行的第一个字段不等于 fred，awk 将继续处理文件而不对当前行执行 print 语句：

$1 == "fred" { print $3 }

awk 提供了完整的比较运算符集合，包括 "=="、"<"、">"、"<="、">=" 和 "!="。另外，awk 还提供了 "~" 和 "!~" 运算符，它们分别表示“匹配”和“不匹配”。它们的用法是在运算符左边指定变量，在右边指定规则表达式。如果某一行的第五个字段包含字符序列 root，那么以下示例将只打印这一行中的第三个字段：

$5 ~ /root/ { print $3 }

条件语句
awk 还提供了非常好的类似于 C 语言的 if 语句。如果您愿意，可以使用 if 语句重写前一个脚本：

{ 
    if ( $5 ~ /root/ ) { 
        print $3 
    }
}

这两个脚本的功能完全一样。第一个示例中，布尔表达式放在代码块外面。而在第二个示例中，将对每一个输入行执行代码块，而且我们使用 if 语句来选择执行 print 命令。这两个方法都可以使用，可以选择最适合脚本其它部分的一种方法。

以下是更复杂的 awk if 语句示例。可以看到，尽管使用了复杂、嵌套的条件语句，if 语句看上去仍与相应的 C 语言 if 语句一样：

{
    if ( $1 == "foo" ) {
        if ( $2 == "foo" ) {
            print "uno"
        } else {
            print "one"
        }
    } else if ($1 == "bar" ) {
        print "two"
    } else {
        print "three"
    }
}

使用 if 语句还可以将代码：

! /matchme/ { print $1 $3 $4 }

转换成：

{   
    if ( $0 !~ /matchme/ ) {
        print $1 $3 $4
    }
}

这两个脚本都只输出不包含 matchme 字符序列的那些行。此外，还可以选择最适合您的代码的方法。它们的功能完全相同。

awk 还允许使用布尔运算符 "||"（逻辑与）和 "&&"（逻辑或），以便创建更复杂的布尔表达式：

( $1 == "foo" ) && ( $2 == "bar" ) { print } 

这个示例只打印第一个字段等于 foo 且第二个字段等于 bar 的那些行。

数值变量！
至今，我们不是打印字符串、整行就是特定字段。然而，awk 还允许我们执行整数和浮点运算。通过使用数学表达式，可以很方便地编写计算文件中空白行数量的脚本。以下就是这样一个脚本：

BEGIN   { x=0 }
/^$/    { x=x+1 }
END     { print "I found " x " blank lines. :)" }

在 BEGIN 块中，将整数变量 x 初始化成零。然后，awk 每次遇到空白行时，awk 将执行 x=x+1 语句，递增 x。处理完所有行之后，执行 END 块，awk 将打印出最终摘要，指出它找到的空白行数量。

字符串化变量
awk 的优点之一就是“简单和字符串化”。我认为 awk 变量“字符串化”是因为所有 awk 变量在内部都是按字符串形式存储的。同时，awk 变量是“简单的”，因为可以对它执行数学操作，且只要变量包含有效数字字符串，awk 会自动处理字符串到数字的转换步骤。要理解我的观点，请研究以下这个示例：

x="1.01"
# We just set x to contain the *string* "1.01"
x=x+1
# We just added one to a *string* 
print x
# Incidentally, these are comments :)

awk 将输出：

2.01

有趣吧！虽然将字符串值 1.01 赋值给变量 x，我们仍然可以对它加一。但在 bash 和 python 中却不能这样做。首先，bash 不支持浮点运算。而且，如果 bash 有“字符串化”变量，它们并不“简单”；要执行任何数学操作，bash 要求我们将数字放到丑陋的 $( ) ) 结构中。如果使用 python，则必须在对 1.01 字符串执行任何数学运算之前，将它转换成浮点值。虽然这并不困难，但它仍是附加的步骤。如果使用 awk，它是全自动的，而那会使我们的代码又好又整洁。如果想要对每个输入行的第一个字段乘方并加一，可以使用以下脚本：

{ print ($1^2)+1 }

如果做一个小实验，就可以发现如果某个特定变量不包含有效数字，awk 在对数学表达式求值时会将该变量当作数字零处理。

众多运算符
awk 的另一个优点是它有完整的数学运算符集合。除了标准的加、减、乘、除，awk 还允许使用前面演示过的指数运算符 "^"、模（余数）运算符 "%" 和其它许多从 C 语言中借入的易于使用的赋值操作符。

这些运算符包括前后加减（i++、--foo）、加／减／乘／除赋值运算符（ a+=3、b*=2、c/=2.2、d-=6.2）。不仅如此 -- 我们还有易于使用的模／指数赋值运算符（a^=2、b%=4）。

字段分隔符
awk 有它自己的特殊变量集合。其中一些允许调整 awk 的运行方式，而其它变量可以被读取以收集关于输入的有用信息。我们已经接触过这些特殊变量中的一个，FS。前面已经提到过，这个变量让您可以设置 awk 要查找的字段之间的字符序列。我们使用 /etc/passwd 作为输入时，将 FS 设置成 ":"。当这样做有问题时，我们还可以更灵活地使用 FS。

FS 值并没有被限制为单一字符；可以通过指定任意长度的字符模式，将它设置成规则表达式。如果正在处理由一个或多个 tab 分隔的字段，您可能希望按以下方式设置 FS：

FS="\t+"

以上示例中，我们使用特殊 "+" 规则表达式字符，它表示“一个或多个前一字符”。

如果字段由空格分隔（一个或多个空格或 tab），您可能想要将 FS 设置成以下规则表达式：

FS="[[:space:]+]"

这个赋值表达式也有问题，它并非必要。为什么？因为缺省情况下，FS 设置成单一空格字符，awk 将这解释成表示“一个或多个空格或 tab”。在这个特殊示例中，缺省 FS 设置恰恰是您最想要的！

复杂的规则表达式也不成问题。即使您的记录由单词 "foo" 分隔，后面跟着三个数字，以下规则表达式仍允许对数据进行正确的分析：

FS="foo[0-9][0-9][0-9]"

字段数量
接着我们要讨论的两个变量通常并不是需要赋值的，而是用来读取以获取关于输入的有用信息。第一个是 NF 变量，也叫做“字段数量”变量。awk 会自动将该变量设置成当前记录中的字段数量。可以使用 NF 变量来只显示某些输入行：

NF == 3 { print "this particular record has three fields: " $0 }

当然，也可以在条件语句中使用 NF 变量，如下：

{   
    if ( NF > 2 ) {
        print $1 " " $2 ":" $3 
    }
}

记录号
记录号 (NR) 是另一个方便的变量。它始终包含当前记录的编号（awk 将第一个记录算作记录号 1）。迄今为止，我们已经处理了每一行包含一个记录的输入文件。对于这些情况，NR 还会告诉您当前行号。然而，当我们在本系列以后部分中开始处理多行记录时，就不会再有这种情况，所以要注意！可以象使用 NF 变量一样使用 NR 来只打印某些输入行：

(NR < 10 ) || (NR > 100) { print "We are on record number 1-9 or 101+" }

另一个示例：

{
    #skip header
    if ( NR > 10 ) {
        print "ok, now for the real information!"
    }
}

awk -v num1=6.6 -v num2=5.5 'BEGIN{print(num1>num2)?"0":"1"}'




2. awk命令格式和选项
2.1. awk的语法有两种形式

    awk [options] 'script' var=value file(s)

    awk [options] -f scriptfile var=value file(s)

2.2. 命令选项

-F fs or --field-separator fs

    指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。
-v var=value or --asign var=value

    赋值一个用户定义变量。
-f scripfile or --file scriptfile

    从脚本文件中读取awk命令。
-mf nnn and -mr nnn

    对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。
-W compact or --compat, -W traditional or --traditional

    在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。
-W copyleft or --copyleft, -W copyright or --copyright

    打印简短的版权信息。
-W help or --help, -W usage or --usage

    打印全部awk选项和每个选项的简短说明。
-W lint or --lint

    打印不能向传统unix平台移植的结构的警告。
-W lint-old or --lint-old

    打印关于不能向传统unix平台移植的结构的警告。
-W posix

    打开兼容模式。但有以下限制，不识别：\x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。
-W re-interval or --re-inerval

    允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。
-W source program-text or --source program-text

    使用program-text作为源代码，可与-f命令混用。
-W version or --version

    打印bug报告信息的版本。

3. 模式和操作

awk脚本是由模式和操作组成的：

    pattern {action} 如$ awk '/root/' test，或$ awk '$3 < 100' test。

两者是可选的，如果没有模式，则action应用到全部记录，如果没有action，则输出匹配全部记录。默认情况下，每一个输入行都是一条记录，但用户可通过RS变量指定不同的分隔符进行分隔。
3.1. 模式

模式可以是以下任意一个：

    /正则表达式/：使用通配符的扩展集。

    关系表达式：可以用下面运算符表中的关系运算符进行操作，可以是字符串或数字的比较，如$2>%1选择第二个字段比第一个字段长的行。

    模式匹配表达式：用运算符~(匹配)和~!(不匹配)。

    模式，模式：指定一个行的范围。该语法不能包括BEGIN和END模式。

    BEGIN：让用户指定在第一条输入记录被处理之前所发生的动作，通常可在这里设置全局变量。

    END：让用户在最后一条输入记录被读取之后发生的动作。

3.2. 操作

操作由一人或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内。主要有四部份：

    变量或数组赋值

    输出命令

    内置函数

    控制流命令

4. awk的环境变量

Table 1. awk的环境变量
变量    描述
$n  当前记录的第n个字段，字段间由FS分隔。
$0  完整的输入记录。
ARGC    命令行参数的数目。
ARGIND  命令行中当前文件的位置(从0开始算)。
ARGV    包含命令行参数的数组。
CONVFMT 数字转换格式(默认值为%.6g)
ENVIRON 环境变量关联数组。
ERRNO   最后一个系统错误的描述。
FIELDWIDTHS 字段宽度列表(用空格键分隔)。
FILENAME    当前文件名。
FNR 同NR，但相对于当前文件。
FS  字段分隔符(默认是任何空格)。
IGNORECASE  如果为真，则进行忽略大小写的匹配。
NF  当前记录中的字段数。
NR  当前记录数。
OFMT    数字的输出格式(默认值是%.6g)。
OFS 输出字段分隔符(默认值是一个空格)。
ORS 输出记录分隔符(默认值是一个换行符)。
RLENGTH 由match函数所匹配的字符串的长度。
RS  记录分隔符(默认是一个换行符)。
RSTART  由match函数所匹配的字符串的第一个位置。
SUBSEP  数组下标分隔符(默认值是\034)。
5. awk运算符

Table 2. 运算符
运算符  描述
= += -= *= /= %= ^= **= 赋值
?:  C条件表达式
||  逻辑或
&&  逻辑与
~ ~!    匹配正则表达式和不匹配正则表达式
< <= > >= != == 关系运算符
空格    连接
+ - 加，减
* / &   乘，除与求余
+ - !   一元加，减和逻辑非
^ ***   求幂
++ --   增加或减少，作为前缀或后缀
$   字段引用
in  数组成员
6. 记录和域
6.1. 记录

awk把每一个以换行符结束的行称为一个记录。

记录分隔符：默认的输入和输出的分隔符都是回车，保存在内建变量ORS和RS中。

$0变量：它指的是整条记录。如$ awk '{print $0}' test将输出test文件中的所有记录。

变量NR：一个计数器，每处理完一条记录，NR的值就增加1。如$ awk '{print NR,$0}' test将输出test文件中所有记录，并在记录前显示记录号。
6.2. 域

记录中每个单词称做“域”，默认情况下以空格或tab分隔。awk可跟踪域的个数，并在内建变量NF中保存该值。如$ awk '{print $1,$3}' test将打印test文件中第一和第三个以空格分开的列(域)。
6.3. 域分隔符

内建变量FS保存输入域分隔符的值，默认是空格或tab。我们可以通过-F命令行选项修改FS的值。如$ awk -F: '{print $1,$5}' test将打印以冒号为分隔符的第一，第五列的内容。

可以同时使用多个域分隔符，这时应该把分隔符写成放到方括号中，如$awk -F'[:\t]' '{print $1,$3}' test，表示以空格、冒号和tab作为分隔符。

输出域的分隔符默认是一个空格，保存在OFS中。如$ awk -F: '{print $1,$5}' test，$1和$5间的逗号就是OFS的值。
7. gawk专用正则表达式元字符

一般通用的元字符集就不讲了，可参考我的Sed和Grep学习笔记。以下几个是gawk专用的，不适合unix版本的awk。

\Y

    匹配一个单词开头或者末尾的空字符串。
\B

    匹配单词内的空字符串。
\<

    匹配一个单词的开头的空字符串，锚定开始。
\>

    匹配一个单词的末尾的空字符串，锚定末尾。
\w

    匹配一个字母数字组成的单词。
\W

    匹配一个非字母数字组成的单词。
\‘

    匹配字符串开头的一个空字符串。
\'

    匹配字符串末尾的一个空字符串。

8. POSIX字符集

可参考我的Grep学习笔记
9. 匹配操作符(~)

用来在记录或者域内匹配正则表达式。如$ awk '$1 ~/^root/' test将显示test文件第一列中以root开头的行。
10. 比较表达式

conditional expression1 ? expression2: expression3，例如：$ awk '{max = {$1 > $3} ? $1: $3: print max}' test。如果第一个域大于第三个域，$1就赋值给max，否则$3就赋值给max。

$ awk '$1 + $2 < 100' test。如果第一和第二个域相加大于100，则打印这些行。

$ awk '$1 > 5 && $2 < 10' test,如果第一个域大于5，并且第二个域小于10，则打印这些行。
11. 范围模板

范围模板匹配从第一个模板的第一次出现到第二个模板的第一次出现之间所有行。如果有一个模板没出现，则匹配到开头或末尾。如$ awk '/root/,/mysql/' test将显示root第一次出现到mysql第一次出现之间的所有行。
12. 一个验证passwd文件有效性的例子

1$ cat /etc/passwd | awk -F: '\
2NF != 7{\
3printf("line %d,does not have 7 fields:%s\n",NR,$0)}\
4$1 !~ /[A-Za-z0-9]/{printf("line %d,non alpha and numeric user id:%d: %s\n,NR,$0)}\
5$2 == "*" {printf("line %d, no password: %s\n",NR,$0)}'

1   

cat把结果输出给awk，awk把域之间的分隔符设为冒号。
2   

如果域的数量(NF)不等于7，就执行下面的程序。
3   

printf打印字符串"line ?? does not have 7 fields"，并显示该条记录。
4   

如果第一个域没有包含任何字母和数字，printf打印“no alpha and numeric user id" ，并显示记录数和记录。
5   

如果第二个域是一个星号，就打印字符串“no passwd”，紧跟着显示记录数和记录本身。
13. 几个实例

    $ awk '/^(no|so)/' test-----打印所有以模式no或so开头的行。

    $ awk '/^[ns]/{print $1}' test-----如果记录以n或s开头，就打印这个记录。

    $ awk '$1 ~/[0-9][0-9]$/(print $1}' test-----如果第一个域以两个数字结束就打印这个记录。

    $ awk '$1 == 100 || $2 < 50' test-----如果第一个或等于100或者第二个域小于50，则打印该行。

    $ awk '$1 != 10' test-----如果第一个域不等于10就打印该行。

    $ awk '/test/{print $1 + 10}' test-----如果记录包含正则表达式test，则第一个域加10并打印出来。

    $ awk '{print ($1 > 5 ? "ok "$1: "error"$1)}' test-----如果第一个域大于5则打印问号后面的表达式值，否则打印冒号后面的表达式值。

    $ awk '/^root/,/^mysql/' test----打印以正则表达式root开头的记录到以正则表达式mysql开头的记录范围内的所有记录。如果找到一个新的正则表达式root开头的记录，则继续打印直到下一个以正则表达式mysql开头的记录为止，或到文件末尾。

14. awk编程
14.1. 变量

    在awk中，变量不需要定义就可以直接使用，变量类型可以是数字或字符串。

    赋值格式：Variable = expression，如$ awk '$1 ~/test/{count = $2 + $3; print count}' test,上式的作用是,awk先扫描第一个域，一旦test匹配，就把第二个域的值加上第三个域的值，并把结果赋值给变量count，最后打印出来。

    awk可以在命令行中给变量赋值，然后将这个变量传输给awk脚本。如$ awk -F: -f awkscript month=4 year=2004 test，上式的month和year都是自定义变量，分别被赋值为4和2004。在awk脚本中，这些变量使用起来就象是在脚本中建立的一样。注意，如果参数前面出现test，那么在BEGIN语句中的变量就不能被使用。

    域变量也可被赋值和修改，如$ awk '{$2 = 100 + $1; print }' test,上式表示，如果第二个域不存在，awk将计算表达式100加$1的值，并将其赋值给$2，如果第二个域存在，则用表达式的值覆盖$2原来的值。再例如：$ awk '$1 == "root"{$1 ="test";print}' test，如果第一个域的值是“root”，则把它赋值为“test”，注意，字符串一定要用双引号。

    内建变量的使用。变量列表在前面已列出，现在举个例子说明一下。$ awk -F: '{IGNORECASE=1; $1 == "MARY"{print NR,$1,$2,$NF}'test，把IGNORECASE设为1代表忽略大小写，打印第一个域是mary的记录数、第一个域、第二个域和最后一个域。

14.2. BEGIN模块

BEGIN模块后紧跟着动作块，这个动作块在awk处理任何输入文件之前执行。所以它可以在没有任何输入的情况下进行测试。它通常用来改变内建变量的值，如OFS,RS和FS等，以及打印标题。如：$ awk 'BEGIN{FS=":"; OFS="\t"; ORS="\n\n"}{print $1,$2,$3} test。上式表示，在处理输入文件以前，域分隔符(FS)被设为冒号，输出文件分隔符(OFS)被设置为制表符，输出记录分隔符(ORS)被设置为两个换行符。$ awk 'BEGIN{print "TITLE TEST"}只打印标题。
14.3. END模块

END不匹配任何的输入文件，但是执行动作块中的所有动作，它在整个输入文件处理完成后被执行。如$ awk 'END{print "The number of records is" NR}' test，上式将打印所有被处理的记录数。
14.4. 重定向和管道

    awk可使用shell的重定向符进行重定向输出，如：$ awk '$1 = 100 {print $1 > "output_file" }' test。上式表示如果第一个域的值等于100，则把它输出到output_file中。也可以用>>来重定向输出，但不清空文件，只做追加操作。

    输出重定向需用到getline函数。getline从标准输入、管道或者当前正在处理的文件之外的其他输入文件获得输入。它负责从输入获得下一行的内容，并给NF,NR和FNR等内建变量赋值。如果得到一条记录，getline函数返回1，如果到达文件的末尾就返回0，如果出现错误，例如打开文件失败，就返回-1。如：

    $ awk 'BEGIN{ "date" | getline d; print d}' test。执行linux的date命令，并通过管道输出给getline，然后再把输出赋值给自定义变量d，并打印它。

    $ awk 'BEGIN{"date" | getline d; split(d,mon); print mon[2]}' test。执行shell的date命令，并通过管道输出给getline，然后getline从管道中读取并将输入赋值给d，split函数把变量d转化成数组mon，然后打印数组mon的第二个元素。

    $ awk 'BEGIN{while( "ls" | getline) print}'，命令ls的输出传递给geline作为输入，循环使getline从ls的输出中读取一行，并把它打印到屏幕。这里没有输入文件，因为BEGIN块在打开输入文件前执行，所以可以忽略输入文件。

    $ awk 'BEGIN{printf "What is your name?"; getline name < "/dev/tty" } $1 ~name {print "Found" name on line ", NR "."} END{print "See you," name "."} test。在屏幕上打印”What is your name?",并等待用户应答。当一行输入完毕后，getline函数从终端接收该行输入，并把它储存在自定义变量name中。如果第一个域匹配变量name的值，print函数就被执行，END块打印See you和name的值。

    $ awk 'BEGIN{while (getline < "/etc/passwd" > 0) lc++; print lc}'。awk将逐行读取文件/etc/passwd的内容，在到达文件末尾前，计数器lc一直增加，当到末尾时，打印lc的值。注意，如果文件不存在，getline返回-1，如果到达文件的末尾就返回0，如果读到一行，就返回1，所以命令 while (getline < "/etc/passwd")在文件不存在的情况下将陷入无限循环，因为返回-1表示逻辑真。

    可以在awk中打开一个管道，且同一时刻只能有一个管道存在。通过close()可关闭管道。如：$ awk '{print $1, $2 | "sort" }' test END {close("sort")}。awd把print语句的输出通过管道作为linux命令sort的输入,END块执行关闭管道操作。

    system函数可以在awk中执行linux的命令。如：$ awk 'BEGIN{system("clear")'。

    fflush函数用以刷新输出缓冲区，如果没有参数，就刷新标准输出的缓冲区，如果以空字符串为参数，如fflush(""),则刷新所有文件和管道的输出缓冲区。

14.5. 条件语句

awk中的条件语句是从C语言中借鉴过来的，可控制程序的流程。
14.5.1. if语句

格式：
        {if (expression){
                   statement; statement; ...
                     }
        }

$ awk '{if ($1 <$2) print $2 "too high"}' test。如果第一个域小于第二个域则打印。

$ awk '{if ($1 < $2) {count++; print "ok"}}' test.如果第一个域小于第二个域，则count加一，并打印ok。
14.5.2. if/else语句，用于双重判断。

格式：
        {if (expression){
                   statement; statement; ...
                       }
        else{
                   statement; statement; ...
                       }
        }

$ awk '{if ($1 > 100) print $1 "bad" ; else print "ok"}' test。如果$1大于100则打印$1 bad,否则打印ok。

$ awk '{if ($1 > 100){ count++; print $1} else {count--; print $2}' test。如果$1大于100，则count加一，并打印$1，否则count减一，并打印$1。
14.5.3. if/else else if语句，用于多重判断。

格式：
        {if (expression){
                    statement; statement; ...
                   }
        else if (expression){
                    statement; statement; ...
                   }
        else if (expression){
                    statement; statement; ...
                   }
        else {
                   statement; statement; ...
             }
        }

14.6. 循环

    awk有三种循环:while循环；for循环；special for循环。

    $ awk '{ i = 1; while ( i <= NF ) { print NF,$i; i++}}' test。变量的初始值为1，若i小于可等于NF(记录中域的个数),则执行打印语句，且i增加1。直到i的值大于NF.

    $ awk '{for (i = 1; i<NF; i++) print NF,$i}' test。作用同上。

    breadkcontinue语句。break用于在满足条件的情况下跳出循环；continue用于在满足条件的情况下忽略后面的语句，直接返回循环的顶端。如：

    {for ( x=3; x<=NF; x++) 
                if ($x<0){print "Bottomed out!"; break}}
    {for ( x=3; x<=NF; x++)
                if ($x==0){print "Get next item"; continue}}
          

    next语句从输入文件中读取一行，然后从头开始执行awk脚本。如：

    {if ($1 ~/test/){next}
        else {print}
    }
         

    exit语句用于结束awk程序，但不会略过END块。退出状态为0代表成功，非零值表示出错。

14.7. 数组

awk中的数组的下标可以是数字和字母，称为关联数组。
14.7.1. 下标与关联数组

    用变量作为数组下标。如：$ awk {name[x++]=$2};END{for(i=0;i<NR;i++) print i,name[i]}' test。数组name中的下标是一个自定义变量x，awk初始化x的值为0，在每次使用后增加1。第二个域的值被赋给name数组的各个元素。在END模块中，for循环被用于循环整个数组，从下标为0的元素开始，打印那些存储在数组中的值。因为下标是关健字，所以它不一定从0开始，可以从任何值开始。

    special for循环用于读取关联数组中的元素。格式如下：

    {for (item in arrayname){
             print arrayname[item]
             }
    }

    $ awk '/^tom/{name[NR]=$1}; END{for(i in name){print name[i]}}' test。打印有值的数组元素。打印的顺序是随机的。

    用字符串作为下标。如：count["test"]

    用域值作为数组的下标。一种新的for循环方式，for (index_value in array) statement。如:$ awk '{count[$1]++} END{for(name in count) print name,count[name]}' test。该语句将打印$1中字符串出现的次数。它首先以第一个域作数组count的下标，第一个域变化，索引就变化。

    delete函数用于删除数组元素。如：$ awk '{line[x++]=$1} END{for(x in line) delete(line[x])}' test。分配给数组line的是第一个域的值，所有记录处理完成后，special for循环将删除每一个元素。

14.8. awk的内建函数
14.8.1. 字符串函数

    sub函数匹配记录中最大、最靠左边的子字符串的正则表达式，并用替换字符串替换这些字符串。如果没有指定目标字符串就默认使用整个记录。替换只发生在第一次匹配的时候。格式如下：

                sub (regular expression, substitution string):
                sub (regular expression, substitution string, target string)

    实例：

                $ awk '{ sub(/test/, "mytest"); print }' testfile
                $ awk '{ sub(/test/, "mytest"); $1}; print }' testfile

    第一个例子在整个记录中匹配，替换只发生在第一次匹配发生的时候。如要在整个文件中进行匹配需要用到gsub

    第二个例子在整个记录的第一个域中进行匹配，替换只发生在第一次匹配发生的时候。

    gsub函数作用如sub，但它在整个文档中进行匹配。格式如下：

                gsub (regular expression, substitution string)
                gsub (regular expression, substitution string, target string)

    实例：

                $ awk '{ gsub(/test/, "mytest"); print }' testfile
                $ awk '{ gsub(/test/, "mytest"), $1 }; print }' testfile

    第一个例子在整个文档中匹配test，匹配的都被替换成mytest。

    第二个例子在整个文档的第一个域中匹配，所有匹配的都被替换成mytest。

    index函数返回子字符串第一次被匹配的位置，偏移量从位置1开始。格式如下：

              index(string, substring)

    实例：

                $ awk '{ print index("test", "mytest") }' testfile

    实例返回test在mytest的位置，结果应该是3。

    length函数返回记录的字符数。格式如下：

                length( string )
                length

    实例：

                $ awk '{ print length( "test" ) }' 
                $ awk '{ print length }' testfile

    第一个实例返回test字符串的长度。

    第二个实例返回testfile文件中第条记录的字符数。

    substr函数返回从位置1开始的子字符串，如果指定长度超过实际长度，就返回整个字符串。格式如下：

                substr( string, starting position )
                substr( string, starting position, length of string )

    实例：

                $ awk '{ print substr( "hello world", 7,11 ) }' 

    上例截取了world子字符串。

    match函数返回在字符串中正则表达式位置的索引，如果找不到指定的正则表达式则返回0。match函数会设置内建变量RSTART为字符串中子字符串的开始位置，RLENGTH为到子字符串末尾的字符个数。substr可利于这些变量来截取字符串。函数格式如下：

                match( string, regular expression )

    实例：

                $ awk '{start=match("this is a test",/[a-z]+$/); print start}'
                $ awk '{start=match("this is a test",/[a-z]+$/); print start, RSTART, RLENGTH }'

    第一个实例打印以连续小写字符结尾的开始位置，这里是11。

    第二个实例还打印RSTART和RLENGTH变量，这里是11(start)，11(RSTART)，4(RLENGTH)。

    toupper和tolower函数可用于字符串大小间的转换，该功能只在gawk中有效。格式如下：

                toupper( string )
                tolower( string )

    实例：

                $ awk '{ print toupper("test"), tolower("TEST") }'

    split函数可按给定的分隔符把字符串分割为一个数组。如果分隔符没提供，则按当前FS值进行分割。格式如下：

                split( string, array, field separator )
                split( string, array )

    实例：

                $ awk '{ split( "20:18:00", time, ":" ); print time[2] }'

    上例把时间按冒号分割到time数组内，并显示第二个数组元素18。

14.8.2. 时间函数

    systime函数返回从1970年1月1日开始到当前时间(不计闰年)的整秒数。格式如下：

                systime()

    实例：

                $ awk '{ now = systime(); print now }'

    strftime函数使用C库中的strftime函数格式化时间。格式如下：

                systime( [format specification][,timestamp] )

    Table 3. 日期和时间格式说明符
    格式    描述
    %a  星期几的缩写(Sun)
    %A  星期几的完整写法(Sunday)
    %b  月名的缩写(Oct)
    %B  月名的完整写法(October)
    %c  本地日期和时间
    %d  十进制日期
    %D  日期 08/20/99
    %e  日期，如果只有一位会补上一个空格
    %H  用十进制表示24小时格式的小时
    %I  用十进制表示12小时格式的小时
    %j  从1月1日起一年中的第几天
    %m  十进制表示的月份
    %M  十进制表示的分钟
    %p  12小时表示法(AM/PM)
    %S  十进制表示的秒
    %U  十进制表示的一年中的第几个星期(星期天作为一个星期的开始)
    %w  十进制表示的星期几(星期天是0)
    %W  十进制表示的一年中的第几个星期(星期一作为一个星期的开始)
    %x  重新设置本地日期(08/20/99)
    %X  重新设置本地时间(12：00：00)
    %y  两位数字表示的年(99)
    %Y  当前月份
    %Z  时区(PDT)
    %%  百分号(%)

    实例：

                $ awk '{ now=strftime( "%D", systime() ); print now }'
                $ awk '{ now=strftime("%m/%d/%y"); print now }'

14.8.3. 内建数学函数

Table 4. 
函数名称    返回值
atan2(x,y)  y,x范围内的余切
cos(x)  余弦函数
exp(x)  求幂
int(x)  取整
log(x)  自然对数
rand()  随机数
sin(x)  正弦
sqrt(x) 平方根
srand(x)    x是rand()函数的种子
int(x)  取整，过程没有舍入
rand()  产生一个大于等于0而小于1的随机数
14.8.4. 自定义函数

在awk中还可自定义函数，格式如下：

        function name ( parameter, parameter, parameter, ... ) {
                        statements
                        return expression                  # the return statement and expression are optional
        }

15. How-to

    如何把一行竖排的数据转换成横排？

    awk '{printf("%s,",$1)}' filename


 vim:ft=man:
