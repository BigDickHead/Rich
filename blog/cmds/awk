
mawk - pattern scanning and text processing language

SYNOPSIS
       mawk [-W option] [-F value] [-v var=value] [--] 'program text' [file ...]
       mawk [-W option] [-F value] [-v var=value] [-f program-file] [--] [file ...]

DESCRIPTION
       mawk  is  an interpreter for the AWK Programming Language.  The AWK language is useful for manipulation of data files,
       text retrieval and processing, and for prototyping and experimenting with algorithms.  mawk is a new  awk  meaning  it
       implements  the AWK language as defined in Aho, Kernighan and Weinberger, The AWK Programming Language, Addison-Wesley
       Publishing, 1988.  (Hereafter referred to as the AWK book.)  mawk conforms to the Posix 1003.2 (draft 11.3) definition
       of  the AWK language which contains a few features not described in the AWK book,  and mawk provides a small number of
       extensions.

       An AWK program is a sequence of pattern {action} pairs and function definitions.  Short programs are  entered  on  the
       command  line  usually enclosed in ' ' to avoid shell interpretation.  Longer programs can be read in from a file with
       the -f option.  Data  input is read from the list of files on the command line or from standard input when the list is
       empty.  The input is broken into records as determined by the record separator variable, RS.  Initially, RS = "\n" and
       records are synonymous with lines.  Each record is compared against each pattern and if it matches, the  program  text
       for {action} is executed.

OPTIONS
       -F value       sets the field separator, FS, to value.

       -f file        Program text is read from file instead of from the command line.  Multiple -f options are allowed.

       -v var=value   assigns value to program variable var.

       --             indicates the unambiguous end of options.

       The  above  options  will  be  available  with any Posix compatible implementation of AWK, and implementation specific
       options are prefaced with -W.  mawk provides six:

       -W version     mawk writes its version and copyright to stdout and compiled limits to stderr and exits 0.

       -W dump        writes an assembler like listing of the internal representation of the program to stdout  and  exits  0
                      (on successful compilation).

       -W interactive sets  unbuffered  writes  to  stdout  and line buffered reads from stdin.  Records from stdin are lines
                      regardless of the value of RS.

       -W exec file   Program text is read from file and this is the last option. Useful  on  systems  that  support  the  #!
                      "magic number" convention for executable scripts.

       -W sprintf=num adjusts  the  size  of  mawk's internal sprintf buffer to num bytes.  More than rare use of this option
                      indicates mawk should be recompiled.

       -W posix_space forces mawk not to consider '\n' to be space.

       The short forms -W[vdiesp] are recognized and on some systems -We is mandatory to avoid command  line  length  limita‐
       tions.

THE AWK LANGUAGE
   1. Program structure
       An AWK program is a sequence of pattern {action} pairs and user function definitions.

       A pattern can be:
              BEGIN
              END
              expression
              expression , expression

       One,  but  not both, of pattern {action} can be omitted.   If {action} is omitted it is implicitly { print }.  If pat‐
       tern is omitted, then it is implicitly matched.  BEGIN and END patterns require an action.

       Statements are terminated by newlines, semi-colons or both.  Groups of statements such as actions or loop  bodies  are
       blocked  via  { ... } as in C.  The last statement in a block doesn't need a terminator.  Blank lines have no meaning;
       an empty statement is terminated with a semi-colon. Long statements can be continued with a backslash, \.  A statement
       can  be  broken without a backslash after a comma, left brace, &&, ||, do, else, the right parenthesis of an if, while
       or for statement, and the right parenthesis of a function definition.  A comment starts with #  and  extends  to,  but
       does not include the end of line.

       The following statements control program flow inside blocks.

              if ( expr ) statement

              if ( expr ) statement else statement

              while ( expr ) statement

              do statement while ( expr )

              for ( opt_expr ; opt_expr ; opt_expr ) statement

              for ( var in array ) statement

              continue

              break

   2. Data types, conversion and comparison
       There  are  two basic data types, numeric and string.  Numeric constants can be integer like -2, decimal like 1.08, or
       in scientific notation like -1.1e4 or .28E-3.  All numbers are represented internally and all computations are done in
       floating point arithmetic.  So for example, the expression 0.2e2 == 20 is true and true is represented as 1.0.

       String constants are enclosed in double quotes.

                                          "This is a string with a newline at the end.\n"

       Strings can be continued across a line by escaping (\) the newline.  The following escape sequences are recognized.

            \\        \
            \"        "
            \a        alert, ascii 7
            \b        backspace, ascii 8
            \t        tab, ascii 9
            \n        newline, ascii 10
            \v        vertical tab, ascii 11
            \f        formfeed, ascii 12
            \r        carriage return, ascii 13
            \ddd      1, 2 or 3 octal digits for ascii ddd
            \xhh      1 or 2 hex digits for ascii  hh

       If you escape any other character \c, you get \c, i.e., mawk ignores the escape.

       There  are  really  three basic data types; the third is number and string which has both a numeric value and a string
       value at the same time.  User defined variables come into existence when first referenced and are initialized to null,
       a  number  and  string  value which has numeric value 0 and string value "".  Non-trivial number and string typed data
       come from input and are typically stored in fields.  (See section 4).

       The type of an expression is determined by its context and automatic type conversion occurs if needed.   For  example,
       to evaluate the statements

            y = x + 2  ;  z = x  "hello"

       The  value  stored  in  variable  y will be typed numeric.  If x is not numeric, the value read from x is converted to
       numeric before it is added to 2 and stored in y.  The value stored in variable z will be typed string, and  the  value
       of x will be converted to string if necessary and concatenated with "hello".  (Of course, the value and type stored in
       x is not changed by any conversions.)  A string expression is converted to numeric using its longest numeric prefix as
       with  atof(3).  A numeric expression is converted to string by replacing expr with sprintf(CONVFMT, expr), unless expr
       can be represented on the host machine as an exact integer then it is converted to sprintf("%d", expr).  Sprintf()  is
       an  AWK built-in that duplicates the functionality of sprintf(3), and CONVFMT is a built-in variable used for internal
       conversion from number to string and initialized to "%.6g".  Explicit type conversions  can  be  forced,  expr  ""  is
       string and expr+0 is numeric.

       To  evaluate, expr1 rel-op expr2, if both operands are numeric or number and string then the comparison is numeric; if
       both operands are string the comparison is string; if one operand is string, the non-string operand is  converted  and
       the comparison is string.  The result is numeric, 1 or 0.

       In  boolean  contexts  such as, if ( expr ) statement, a string expression evaluates true if and only if it is not the
       empty string ""; numeric values if and only if not numerically zero.

   3. Regular expressions
       In the AWK language, records, fields and strings are often tested for matching a regular expression.  Regular  expres‐
       sions are enclosed in slashes, and

            expr ~ /r/

       is an AWK expression that evaluates to 1 if expr "matches" r, which means a substring of expr is in the set of strings
       defined by r.  With no match the expression evaluates to 0; replacing ~ with the "not match" operator, !~  ,  reverses
       the meaning.  As  pattern-action pairs,

            /r/ { action }   and   $0 ~ /r/ { action }

       are the same, and for each input record that matches r, action is executed.  In fact, /r/ is an AWK expression that is
       equivalent to ($0 ~ /r/) anywhere except when on the right side of a match operator or passed  as  an  argument  to  a
       built-in function that expects a regular expression argument.

       AWK  uses extended regular expressions as with egrep(1).  The regular expression metacharacters, i.e., those with spe‐
       cial meaning in regular expressions are

             ^ $ . [ ] | ( ) * + ?

       Regular expressions are built up from characters as follows:

              c            matches any non-metacharacter c.

              \c           matches a character defined by the same escape sequences used in string constants or  the  literal
                           character c if \c is not an escape sequence.

              .            matches any character (including newline).

              ^            matches the front of a string.

              $            matches the back of a string.

              [c1c2c3...]  matches  any character in the class c1c2c3... .  An interval of characters is denoted c1-c2 inside
                           a class [...].

              [^c1c2c3...] matches any character not in the class c1c2c3...

       Regular expressions are built up from other regular expressions as follows:

              r1r2         matches r1 followed immediately by r2 (concatenation).

              r1 | r2      matches r1 or r2 (alternation).

              r*           matches r repeated zero or more times.

              r+           matches r repeated one or more times.

              r?           matches r zero or once.

              (r)          matches r, providing grouping.

       The increasing precedence of operators is alternation, concatenation and unary (*, + or ?).

       For example,

            /^[_a-zA-Z][_a-zA-Z0-9]*$/  and
            /^[-+]?([0-9]+\.?|\.[0-9])[0-9]*([eE][-+]?[0-9]+)?$/

       are matched by AWK identifiers and AWK numeric constants respectively.  Note that . has to be escaped to be recognized
       as a decimal point, and that metacharacters are not special inside character classes.

       Any expression can be used on the right hand side of the ~ or !~ operators or passed to a built-in that expects a reg‐
       ular expression.  If needed, it is converted to string, and then interpreted as a regular expression.  For example,

            BEGIN { identifier = "[_a-zA-Z][_a-zA-Z0-9]*" }

            $0 ~ "^" identifier

       prints all lines that start with an AWK identifier.

       mawk recognizes the empty regular expression, //, which matches the empty string and hence is matched by any string at
       the front, back and between every character.  For example,

            echo  abc | mawk { gsub(//, "X") ; print }
            XaXbXcX


   4. Records and fields
       Records  are  read  in  one at a time, and stored in the field variable $0.  The record is split into fields which are
       stored in $1, $2, ..., $NF.  The built-in variable NF is set to the number of fields, and NR and FNR  are  incremented
       by 1.  Fields above $NF are set to "".

       Assignment  to  $0  causes  the fields and NF to be recomputed.  Assignment to NF or to a field causes $0 to be recon‐
       structed by concatenating the $i's separated by OFS.  Assignment to a field with index greater than NF,  increases  NF
       and causes $0 to be reconstructed.

       Data  input  stored  in  fields  is  string,  unless the entire field has numeric form and then the type is number and
       string.  For example,

            echo 24 24E |
            mawk '{ print($1>100, $1>"100", $2>100, $2>"100") }'
            0 1 1 1

       $0 and $2 are string and $1 is number and string.  The first comparison is numeric, the second is string, the third is
       string (100 is converted to "100"), and the last is string.

   5. Expressions and operators
       The  expression  syntax  is  similar  to  C.   Primary expressions are numeric constants, string constants, variables,
       fields, arrays and function calls.  The identifier for a variable, array or function can be  a  sequence  of  letters,
       digits  and  underscores,  that does not start with a digit.  Variables are not declared; they exist when first refer‐
       enced and are initialized to null.

       New expressions are composed with the following operators in order of increasing precedence.

              assignment          =  +=  -=  *=  /=  %=  ^=
              conditional         ?  :
              logical or          ||
              logical and         &&
              array membership    in
              matching       ~   !~
              relational          <  >   <=  >=  ==  !=
              concatenation       (no explicit operator)
              add ops             +  -
              mul ops             *  /  %
              unary               +  -
              logical not         !
              exponentiation      ^
              inc and dec         ++ -- (both post and pre)
              field               $

       Assignment, conditional and exponentiation associate right to left; the other operators associate left to right.   Any
       expression can be parenthesized.

   6. Arrays
       Awk  provides  one-dimensional  arrays.  Array elements are expressed as array[expr].  Expr is internally converted to
       string type, so, for example, A[1] and A["1"] are the same element and the actual index is  "1".   Arrays  indexed  by
       strings  are  called associative arrays.  Initially an array is empty; elements exist when first accessed.  An expres‐
       sion, expr in array evaluates to 1 if array[expr] exists, else to 0.

       There is a form of the for statement that loops over each index of an array.

            for ( var in array ) statement

       sets var to each index of array and executes statement.  The order that var transverses the indices of  array  is  not
       defined.

       The  statement,  delete array[expr], causes array[expr] not to exist.  mawk supports an extension, delete array, which
       deletes all elements of array.

       Multidimensional arrays are synthesized with concatenation using the built-in variable SUBSEP.  array[expr1,expr2]  is
       equivalent to array[expr1 SUBSEP expr2].  Testing for a multidimensional element uses a parenthesized index, such as

            if ( (i, j) in A )  print A[i, j]


   7. Builtin-variables
       The following variables are built-in and initialized before program execution.

              ARGC      number of command line arguments.

              ARGV      array of command line arguments, 0..ARGC-1.

              CONVFMT   format for internal conversion of numbers to string, initially = "%.6g".

              ENVIRON   array indexed by environment variables.  An environment string, var=value is stored as ENVIRON[var] =
                        value.

              FILENAME  name of the current input file.

              FNR       current record number in FILENAME.

              FS        splits records into fields as a regular expression.

              NF        number of fields in the current record.

              NR        current record number in the total input stream.

              OFMT      format for printing numbers; initially = "%.6g".

              OFS       inserted between fields on output, initially = " ".

              ORS       terminates each record on output, initially = "\n".

              RLENGTH   length set by the last call to the built-in function, match().

              RS        input record separator, initially = "\n".

              RSTART    index set by the last call to match().

              SUBSEP    used to build multiple array subscripts, initially = "\034".

   8. Built-in functions
       String functions

              gsub(r,s,t)  gsub(r,s)
                     Global substitution, every match of regular expression r in variable t is replaced  by  string  s.   The
                     number  of  replacements is returned.  If t is omitted, $0 is used.  An & in the replacement string s is
                     replaced by the matched substring of t.  \& and \\ put  literal & and \, respectively, in  the  replace‐
                     ment string.

              index(s,t)
                     If  t  is a substring of s, then the position where t starts is returned, else 0 is returned.  The first
                     character of s is in position 1.

              length(s)
                     Returns the length of string s.

              match(s,r)
                     Returns the index of the first longest match of regular expression r in  string  s.   Returns  0  if  no
                     match.   As a side effect, RSTART is set to the return value.  RLENGTH is set to the length of the match
                     or -1 if no match.  If the empty string is matched, RLENGTH is set to 0, and 1 is returned if the  match
                     is at the front, and length(s)+1 is returned if the match is at the back.

              split(s,A,r)  split(s,A)
                     String  s is split into fields by regular expression r and the fields are loaded into array A.  The num‐
                     ber of fields is returned.  See section 11 below for more detail.  If r is omitted, FS is used.

              sprintf(format,expr-list)
                     Returns a string constructed from expr-list according to format.  See the description of printf() below.

              sub(r,s,t)  sub(r,s)
                     Single substitution, same as gsub() except at most one substitution.

              substr(s,i,n)  substr(s,i)
                     Returns the substring of string s, starting at index i, of length n.  If n is omitted, the suffix of  s,
                     starting at i is returned.

              tolower(s)
                     Returns a copy of s with all upper case characters converted to lower case.

              toupper(s)
                     Returns a copy of s with all lower case characters converted to upper case.

       Arithmetic functions

              atan2(y,x)     Arctan of y/x between -pi and pi.

              cos(x)         Cosine function, x in radians.

              exp(x)         Exponential function.

              int(x)         Returns x truncated towards zero.

              log(x)         Natural logarithm.

              rand()         Returns a random number between zero and one.

              sin(x)         Sine function, x in radians.

              sqrt(x)        Returns square root of x.

              srand(expr)  srand()
                     Seeds the random number generator, using the clock if expr is omitted, and returns the value of the pre‐
                     vious seed.  mawk seeds the random number generator from the clock at startup so there is no  real  need
                     to call srand().  Srand(expr) is useful for repeating pseudo random sequences.

   9. Input and output
       There are two output statements, print and printf.

              print  writes $0  ORS to standard output.

              print expr1, expr2, ..., exprn
                     writes  expr1  OFS  expr2  OFS  ...  exprn ORS to standard output.  Numeric expressions are converted to
                     string with OFMT.

              printf format, expr-list
                     duplicates the printf C library function writing to standard output.  The complete ANSI C format  speci‐
                     fications are recognized with conversions %c, %d, %e, %E, %f, %g, %G, %i, %o, %s, %u, %x, %X and %%, and
                     conversion qualifiers h and l.

       The argument list to print or printf can optionally be enclosed in parentheses.  Print formats numbers using  OFMT  or
       "%d"  for  exact integers.  "%c" with a numeric argument prints the corresponding 8 bit character, with a string argu‐
       ment it prints the first character of the string.  The output of print and printf can be redirected to a file or  com‐
       mand  by  appending > file, >> file or | command to the end of the print statement.  Redirection opens file or command
       only once, subsequent redirections append to the already open stream.  By convention,  mawk  associates  the  filename
       "/dev/stderr"  with  stderr  which  allows  print and printf to be redirected to stderr.  mawk also associates "-" and
       "/dev/stdout" with stdin and stdout which allows these streams to be passed to functions.

       The input function getline has the following variations.

              getline
                     reads into $0, updates the fields, NF, NR and FNR.

              getline < file
                     reads into $0 from file, updates the fields and NF.

              getline var
                     reads the next record into var, updates NR and FNR.

              getline var < file
                     reads the next record of file into var.

               command | getline
                     pipes a record from command into $0 and updates the fields and NF.

               command | getline var
                     pipes a record from command into var.

       Getline returns 0 on end-of-file, -1 on error, otherwise 1.

       Commands on the end of pipes are executed by /bin/sh.

       The function close(expr) closes the file or pipe associated with expr.  Close returns 0 if expr is an open  file,  the
       exit  status  if  expr is a piped command, and -1 otherwise.  Close is used to reread a file or command, make sure the
       other end of an output pipe is finished or conserve file resources.

       The function fflush(expr) flushes the output file or pipe associated with expr.  Fflush returns 0 if expr is  an  open
       output  stream  else  -1.   Fflush without an argument flushes stdout.  Fflush with an empty argument ("") flushes all
       open output.

       The function system(expr) uses /bin/sh to execute expr and returns the exit status of the command expr.  Changes  made
       to the ENVIRON array are not passed to commands executed with system or pipes.

   10. User defined functions
       The syntax for a user defined function is

            function name( args ) { statements }

       The function body can contain a return statement

            return opt_expr

       A  return  statement is not required.  Function calls may be nested or recursive.  Functions are passed expressions by
       value and arrays by reference.  Extra arguments serve as local variables and are initialized to  null.   For  example,
       csplit(s,A) puts each character of s into array A and returns the length of s.

            function csplit(s, A,    n, i)
            {
              n = length(s)
              for( i = 1 ; i <= n ; i++ ) A[i] = substr(s, i, 1)
              return n
            }

       Putting  extra space between passed arguments and local variables is conventional.  Functions can be referenced before
       they are defined, but the function name and the '(' of the arguments must touch to avoid confusion with concatenation.

   11. Splitting strings, records and files
       Awk programs use the same algorithm to split strings into arrays with split(), and records into fields  on  FS.   mawk
       uses essentially the same algorithm to split files into records on RS.

       Split(expr,A,sep) works as follows:

              (1)    If  sep  is omitted, it is replaced by FS.  Sep can be an expression or regular expression.  If it is an
                     expression of non-string type, it is converted to string.

              (2)    If sep = " " (a single space), then <SPACE> is trimmed from the front and back of expr, and sep  becomes
                     <SPACE>.  mawk defines <SPACE> as the regular expression /[ \t\n]+/.  Otherwise sep is treated as a reg‐
                     ular expression, except that meta-characters are ignored for a string of length  1,  e.g.,  split(x,  A,
                     "*") and split(x, A, /\*/) are the same.

              (3)    If  expr is not string, it is converted to string.  If expr is then the empty string "", split() returns
                     0 and A is set empty.  Otherwise, all non-overlapping, non-null and longest matches of sep in expr, sep‐
                     arate  expr  into  fields  which  are loaded into A.  The fields are placed in A[1], A[2], ..., A[n] and
                     split() returns n, the number of fields which is the number of matches plus one.  Data placed in A  that
                     looks numeric is typed number and string.

       Splitting records into fields works the same except the pieces are loaded into $1, $2,..., $NF.  If $0 is empty, NF is
       set to 0 and all $i to "".

       mawk splits files into records by the same algorithm, but with the slight difference that RS is  really  a  terminator
       instead of a separator.  (ORS is really a terminator too).

              E.g.,  if  FS  =  ":+" and $0 = "a::b:" , then NF = 3 and $1 = "a", $2 = "b" and $3 = "", but if "a::b:" is the
              contents of an input file and RS = ":+", then there are two records "a" and "b".

       RS = " " is not special.

       If FS = "", then mawk breaks the record into individual characters, and, similarly, split(s,A,"") places the  individ‐
       ual characters of s into A.

   12. Multi-line records
       Since  mawk  interprets  RS  as a regular expression, multi-line records are easy.  Setting RS = "\n\n+", makes one or
       more blank lines separate records.  If FS = " " (the default), then single newlines, by the rules for  <SPACE>  above,
       become space and single newlines are field separators.

              For example, if a file is "a b\nc\n\n", RS = "\n\n+" and FS = " ", then there is one record "a b\nc" with three
              fields "a", "b" and "c".  Changing FS = "\n", gives two fields "a b" and "c"; changing FS = "", gives one field
              identical to the record.

       If  you want lines with spaces or tabs to be considered blank, set RS = "\n([ \t]*\n)+".  For compatibility with other
       awks, setting RS = "" has the same effect as if blank lines are stripped from the front and back  of  files  and  then
       records  are determined as if RS = "\n\n+".  Posix requires that "\n" always separates records when RS = "" regardless
       of the value of FS.  mawk does not support this convention, because defining "\n" as <SPACE> makes it unnecessary.

       Most of the time when you change RS for multi-line records, you will also want to change ORS to "\n\n" so  the  record
       spacing is preserved on output.

   13. Program execution
       This  section  describes  the order of program execution.  First ARGC is set to the total number of command line argu‐
       ments passed to the execution phase of the program.  ARGV[0] is set the name of the AWK interpreter  and  ARGV[1]  ...
       ARGV[ARGC-1] holds the remaining command line arguments exclusive of options and program source.  For example with

            mawk  -f  prog  v=1  A  t=hello  B

       ARGC = 5 with ARGV[0] = "mawk", ARGV[1] = "v=1", ARGV[2] = "A", ARGV[3] = "t=hello" and ARGV[4] = "B".

       Next,  each BEGIN block is executed in order.  If the program consists entirely of BEGIN blocks, then execution termi‐
       nates, else an input stream is opened and execution continues.  If ARGC equals 1, the input stream is  set  to  stdin,
       else  the command line arguments ARGV[1] ...  ARGV[ARGC-1] are examined for a file argument.

       The  command  line  arguments  divide  into three sets: file arguments, assignment arguments and empty strings "".  An
       assignment has the form var=string.  When an ARGV[i] is examined as a possible file argument, if it  is  empty  it  is
       skipped;  if  it  is  an assignment argument, the assignment to var takes place and i skips to the next argument; else
       ARGV[i] is opened for input.  If it fails to open, execution terminates with exit code 2.  If no command line argument
       is  a  file  argument,  then  input  comes from stdin.  Getline in a BEGIN action opens input.  "-" as a file argument
       denotes stdin.

       Once an input stream is open, each input record is tested against each pattern, and  if  it  matches,  the  associated
       action  is executed.  An expression pattern matches if it is boolean true (see the end of section 2).  A BEGIN pattern
       matches before any input has been read, and an END pattern matches after all input has been read.   A  range  pattern,
       expr1,expr2 , matches every record between the match of expr1 and the match expr2 inclusively.

       When  end  of  file occurs on the input stream, the remaining command line arguments are examined for a file argument,
       and if there is one it is opened, else the END pattern is considered matched and all END actions are executed.

       In the example, the assignment v=1 takes place after the BEGIN actions are executed, and the data placed in v is typed
       number and string.  Input is then read from file A.  On end of file A, t is set to the string "hello", and B is opened
       for input.  On end of file B, the END actions are executed.

       Program flow at the pattern {action} level can be changed with the

            next
            exit  opt_expr

       statements.  A next statement causes the next input record to be read and pattern testing to restart  with  the  first
       pattern {action} pair in the program.  An exit statement causes immediate execution of the END actions or program ter‐
       mination if there are none or if the exit occurs in an END action.  The opt_expr sets the exit value  of  the  program
       unless overridden by a later exit or subsequent error.

EXAMPLES
       1. emulate cat.

            { print }

       2. emulate wc.

            { chars += length($0) + 1  # add one for the \n
              words += NF
            }

            END{ print NR, words, chars }

       3. count the number of unique "real words".

            BEGIN { FS = "[^A-Za-z]+" }

            { for(i = 1 ; i <= NF ; i++)  word[$i] = "" }

            END { delete word[""]
                  for ( i in word )  cnt++
                  print cnt
            }

       4. sum the second field of every record based on the first field.

            $1 ~ /credit|gain/ { sum += $2 }
            $1 ~ /debit|loss/  { sum -= $2 }

            END { print sum }

       5. sort a file, comparing as string

            { line[NR] = $0 "" }  # make sure of comparison type
                            # in case some lines look numeric

            END {  isort(line, NR)
              for(i = 1 ; i <= NR ; i++) print line[i]
            }

            #insertion sort of A[1..n]
            function isort( A, n,    i, j, hold)
            {
              for( i = 2 ; i <= n ; i++)
              {
                hold = A[j = i]
                while ( A[j-1] > hold )
                { j-- ; A[j+1] = A[j] }
                A[j] = hold
              }
              # sentinel A[0] = "" will be created if needed
            }


COMPATIBILITY ISSUES
       The  Posix 1003.2(draft 11.3) definition of the AWK language is AWK as described in the AWK book with a few extensions
       that appeared in SystemVR4 nawk. The extensions are:

              New functions: toupper() and tolower().

              New variables: ENVIRON[] and CONVFMT.

              ANSI C conversion specifications for printf() and sprintf().

              New command options:  -v var=value, multiple -f options and implementation options as arguments to -W.


       Posix AWK is oriented to operate on files a line at a time.  RS can be changed from "\n" to another single  character,
       but it is hard to find any use for this — there are no examples in the AWK book.  By convention, RS = "", makes one or
       more blank lines separate records, allowing multi-line records.  When RS =  "",  "\n"  is  always  a  field  separator
       regardless of the value in FS.

       mawk,  on the other hand, allows RS to be a regular expression.  When "\n" appears in records, it is treated as space,
       and FS always determines fields.

       Removing the line at a time paradigm can make some programs simpler and can often improve performance.   For  example,
       redoing example 3 from above,

            BEGIN { RS = "[^A-Za-z]+" }

            { word[ $0 ] = "" }

            END { delete  word[ "" ]
              for( i in word )  cnt++
              print cnt
            }

       counts  the number of unique words by making each word a record.  On moderate size files, mawk executes twice as fast,
       because of the simplified inner loop.

       The following program replaces each comment by a single space in a C program file,

            BEGIN {
              RS = "/\*([^*]|\*+[^/*])*\*+/"
                 # comment is record separator
              ORS = " "
              getline  hold
              }

              { print hold ; hold = $0 }

              END { printf "%s" , hold }

       Buffering one record is needed to avoid terminating the last record with a space.

       With mawk, the following are all equivalent,

            x ~ /a\+b/    x ~ "a\+b"     x ~ "a\\+b"

       The strings get scanned twice, once as string and once as regular expression.  On the string scan,  mawk  ignores  the
       escape  on  non-escape  characters  while  the  AWK book advocates \c be recognized as c which necessitates the double
       escaping of meta-characters in strings.  Posix explicitly declines to define the behavior which passively forces  pro‐
       grams that must run under a variety of awks to use the more portable but less readable, double escape.

       Posix  AWK  does  not recognize "/dev/std{out,err}" or \x hex escape sequences in strings.  Unlike ANSI C, mawk limits
       the number of digits that follows \x to two as the current implementation only supports 8 bit characters.  The  built-
       in  fflush  first  appeared  in  a  recent  (1993) AT&T awk released to netlib, and is not part of the posix standard.
       Aggregate deletion with delete array is not part of the posix standard.

       Posix explicitly leaves the behavior of FS = "" undefined, and mentions splitting the record into characters as a pos‐
       sible interpretation, but currently this use is not portable across implementations.

       Finally, here is how mawk handles exceptional cases not discussed in the AWK book or the Posix draft.  It is unsafe to
       assume consistency across awks and safe to skip to the next section.

              substr(s, i, n) returns the characters of s in the intersection of the closed interval [1, length(s)]  and  the
              half-open  interval  [i, i+n).  When this intersection is empty, the empty string is returned; so substr("ABC",
              1, 0) = "" and substr("ABC", -4, 6) = "A".

              Every string, including the empty string, matches the empty string at the front so, s ~ //  and  s  ~  "",  are
              always 1 as is match(s, //) and match(s, "").  The last two set RLENGTH to 0.

              index(s,  t)  is  always the same as match(s, t1) where t1 is the same as t with metacharacters escaped.  Hence
              consistency with match requires that index(s, "") always returns 1.  Also the condition, index(s,t) != 0 if and
              only t is a substring of s, requires index("","") = 1.

              If  getline encounters end of file, getline var, leaves var unchanged.  Similarly, on entry to the END actions,
              $0, the fields and NF have their value unaltered from the last record.

SEE ALSO
       egrep(1)

       Aho, Kernighan and Weinberger, The AWK Programming Language, Addison-Wesley Publishing, 1988, (the AWK book),  defines
       the  language,  opening  with a tutorial and advancing to many interesting programs that delve into issues of software
       design and analysis relevant to programming in any language.

       The GAWK Manual, The Free Software Foundation, 1991, is a tutorial and language reference that does  not  attempt  the
       depth  of the AWK book and assumes the reader may be a novice programmer.  The section on AWK arrays is excellent.  It
       also discusses Posix requirements for AWK.

================================================================================================================
#!/bin/bash
VER=`java -version 2>&1 | grep "java version" | awk '{print $3}' | tr -d \" | awk '{split($0, array, ".")} END{print array[2]}'`
if [[ $VER -ge 6 ]]; then
    echo " >= 1.6"
else
    echo " <= 1.6"
fi
================================================================================================================

    
第一个 awk

$ awk '{ print }' /etc/passwd

您将会见到 /etc/passwd 文件的内容出现在眼前。现在，解释 awk 做了些什么。调用 awk 时，我们指定 /etc/passwd 作为输入文件。执行 awk 时，它依次对 /etc/passwd 中的每一行执行 print 命令。所有输出都发送到 stdout，所得到的结果与与执行catting /etc/passwd完全相同。

现在，解释 { print } 代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。

这里是另一个 awk 示例，它的作用与上例完全相同：

$ awk '{ print $0 }' /etc/passwd

在 awk 中，$0 变量表示整个当前行，所以 print 和 print $0 的作用完全一样。

如果您愿意，可以创建一个 awk 程序，让它输出与输入数据完全无关的数据。以下是一个示例：

$ awk '{ print "" }' /etc/passwd

只要将 "" 字符串传递给 print 命令，它就会打印空白行。如果测试该脚本，将会发现对于 /etc/passwd 文件中的每一行，awk 都输出一个空白行。再次说明， awk 对输入文件中的每一行都执行这个脚本。以下是另一个示例：

$ awk '{ print "hiya" }' /etc/passwd

运行这个脚本将在您的屏幕上写满 hiya。:)

多个字段
awk 非常善于处理分成多个逻辑字段的文本，而且让您可以毫不费力地引用 awk 脚本中每个独立的字段。以下脚本将打印出您的系统上所有用户帐户的列表：

$ awk -F":" '{ print $1 }' /etc/passwd

上例中，在调用 awk 时，使用 -F 选项来指定 ":" 作为字段分隔符。awk 处理 print $1 命令时，它会打印出在输入文件中每一行中出现的第一个字段。以下是另一个示例：

$ awk -F":" '{ print $1 $3 }' /etc/passwd

以下是该脚本输出的摘录：

halt7
operator11
root0
shutdown6
sync5
bin1
....etc.

如您所见，awk 打印出 /etc/passwd 文件的第一和第三个字段，它们正好分别是用户名和用户标识字段。现在，当脚本运行时，它并不理想 -- 在两个输出字段之间没有空格！如果习惯于使用 bash 或 python 进行编程，那么您会指望 print $1 $3 命令在两个字段之间插入空格。然而，当两个字符串在 awk 程序中彼此相邻时，awk 会连接它们但不在它们之间添加空格。以下命令会在这两个字段中插入空格：

$ awk -F":" '{ print $1 " " $3 }' /etc/passwd

以这种方式调用 print 时，它将连接 $1、" " 和 $3，创建可读的输出。当然，如果需要的话，我们还可以插入一些文本标签：

$ awk -F":" '{ print "username: " $1 "\t\tuid:" $3" }' /etc/passwd

这将产生以下输出：

username: halt          uid:7
username: operator      uid:11
username: root          uid:0
username: shutdown      uid:6
username: sync          uid:5
username: bin           uid:1
....etc.

外部脚本
将脚本作为命令行自变量传递给 awk 对于小的单行程序来说是非常简单的，而对于多行程序，它就比较复杂。您肯定想要在外部文件中撰写脚本。然后可以向 awk 传递 -f 选项，以向它提供此脚本文件：

$ awk -f myscript.awk myfile.in

将脚本放入文本文件还可以让您使用附加 awk 功能。例如，这个多行脚本与前面的单行脚本的作用相同，它们都打印出 /etc/passwd 中每一行的第一个字段：

BEGIN {
    FS=":"
}

{ print $1 }

这两个方法的差别在于如何设置字段分隔符。在这个脚本中，字段分隔符在代码自身中指定（通过设置 FS 变量），而在前一个示例中，通过在命令行上向 awk 传递 -F":" 选项来设置 FS。通常，最好在脚本自身中设置字段分隔符，只是因为这表示您可以少输入一个命令行自变量。我们将在本文的后面详细讨论 FS 变量。

BEGIN 和 END 块
通常，对于每个输入行，awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之前执行初始化代码。对于这种情况，awk 允许您定义一个 BEGIN 块。我们在前一个示例中使用了 BEGIN 块。因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。

awk 还提供了另一个特殊块，叫作 END 块。awk 在处理了输入文件中的所有行之后执行这个块。通常，END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。

规则表达式和块
awk 允许使用规则表达式，根据规则表达式是否匹配当前行来选择执行独立代码块。以下示例脚本只输出包含字符序列 foo 的那些行：

/foo/ { print }

当然，可以使用更复杂的规则表达式。以下脚本将只打印包含浮点数的行：

/[0-9]+\.[0-9]*/ { print }

表达式和块
还有许多其它方法可以选择执行代码块。我们可以将任意一种布尔表达式放在一个代码块之前，以控制何时执行某特定块。仅当对前面的布尔表达式求值为真时，awk 才执行代码块。以下示例脚本输出将输出其第一个字段等于 fred 的所有行中的第三个字段。如果当前行的第一个字段不等于 fred，awk 将继续处理文件而不对当前行执行 print 语句：

$1 == "fred" { print $3 }

awk 提供了完整的比较运算符集合，包括 "=="、"<"、">"、"<="、">=" 和 "!="。另外，awk 还提供了 "~" 和 "!~" 运算符，它们分别表示“匹配”和“不匹配”。它们的用法是在运算符左边指定变量，在右边指定规则表达式。如果某一行的第五个字段包含字符序列 root，那么以下示例将只打印这一行中的第三个字段：

$5 ~ /root/ { print $3 }

条件语句
awk 还提供了非常好的类似于 C 语言的 if 语句。如果您愿意，可以使用 if 语句重写前一个脚本：

{ 
    if ( $5 ~ /root/ ) { 
        print $3 
    }
}

这两个脚本的功能完全一样。第一个示例中，布尔表达式放在代码块外面。而在第二个示例中，将对每一个输入行执行代码块，而且我们使用 if 语句来选择执行 print 命令。这两个方法都可以使用，可以选择最适合脚本其它部分的一种方法。

以下是更复杂的 awk if 语句示例。可以看到，尽管使用了复杂、嵌套的条件语句，if 语句看上去仍与相应的 C 语言 if 语句一样：

{
    if ( $1 == "foo" ) {
        if ( $2 == "foo" ) {
            print "uno"
        } else {
            print "one"
        }
    } else if ($1 == "bar" ) {
        print "two"
    } else {
        print "three"
    }
}

使用 if 语句还可以将代码：

! /matchme/ { print $1 $3 $4 }

转换成：

{   
    if ( $0 !~ /matchme/ ) {
        print $1 $3 $4
    }
}

这两个脚本都只输出不包含 matchme 字符序列的那些行。此外，还可以选择最适合您的代码的方法。它们的功能完全相同。

awk 还允许使用布尔运算符 "||"（逻辑与）和 "&&"（逻辑或），以便创建更复杂的布尔表达式：

( $1 == "foo" ) && ( $2 == "bar" ) { print } 

这个示例只打印第一个字段等于 foo 且第二个字段等于 bar 的那些行。

数值变量！
至今，我们不是打印字符串、整行就是特定字段。然而，awk 还允许我们执行整数和浮点运算。通过使用数学表达式，可以很方便地编写计算文件中空白行数量的脚本。以下就是这样一个脚本：

BEGIN   { x=0 }
/^$/    { x=x+1 }
END     { print "I found " x " blank lines. :)" }

在 BEGIN 块中，将整数变量 x 初始化成零。然后，awk 每次遇到空白行时，awk 将执行 x=x+1 语句，递增 x。处理完所有行之后，执行 END 块，awk 将打印出最终摘要，指出它找到的空白行数量。

字符串化变量
awk 的优点之一就是“简单和字符串化”。我认为 awk 变量“字符串化”是因为所有 awk 变量在内部都是按字符串形式存储的。同时，awk 变量是“简单的”，因为可以对它执行数学操作，且只要变量包含有效数字字符串，awk 会自动处理字符串到数字的转换步骤。要理解我的观点，请研究以下这个示例：

x="1.01"
# We just set x to contain the *string* "1.01"
x=x+1
# We just added one to a *string* 
print x
# Incidentally, these are comments :)

awk 将输出：

2.01

有趣吧！虽然将字符串值 1.01 赋值给变量 x，我们仍然可以对它加一。但在 bash 和 python 中却不能这样做。首先，bash 不支持浮点运算。而且，如果 bash 有“字符串化”变量，它们并不“简单”；要执行任何数学操作，bash 要求我们将数字放到丑陋的 $( ) ) 结构中。如果使用 python，则必须在对 1.01 字符串执行任何数学运算之前，将它转换成浮点值。虽然这并不困难，但它仍是附加的步骤。如果使用 awk，它是全自动的，而那会使我们的代码又好又整洁。如果想要对每个输入行的第一个字段乘方并加一，可以使用以下脚本：

{ print ($1^2)+1 }

如果做一个小实验，就可以发现如果某个特定变量不包含有效数字，awk 在对数学表达式求值时会将该变量当作数字零处理。

众多运算符
awk 的另一个优点是它有完整的数学运算符集合。除了标准的加、减、乘、除，awk 还允许使用前面演示过的指数运算符 "^"、模（余数）运算符 "%" 和其它许多从 C 语言中借入的易于使用的赋值操作符。

这些运算符包括前后加减（i++、--foo）、加／减／乘／除赋值运算符（ a+=3、b*=2、c/=2.2、d-=6.2）。不仅如此 -- 我们还有易于使用的模／指数赋值运算符（a^=2、b%=4）。

字段分隔符
awk 有它自己的特殊变量集合。其中一些允许调整 awk 的运行方式，而其它变量可以被读取以收集关于输入的有用信息。我们已经接触过这些特殊变量中的一个，FS。前面已经提到过，这个变量让您可以设置 awk 要查找的字段之间的字符序列。我们使用 /etc/passwd 作为输入时，将 FS 设置成 ":"。当这样做有问题时，我们还可以更灵活地使用 FS。

FS 值并没有被限制为单一字符；可以通过指定任意长度的字符模式，将它设置成规则表达式。如果正在处理由一个或多个 tab 分隔的字段，您可能希望按以下方式设置 FS：

FS="\t+"

以上示例中，我们使用特殊 "+" 规则表达式字符，它表示“一个或多个前一字符”。

如果字段由空格分隔（一个或多个空格或 tab），您可能想要将 FS 设置成以下规则表达式：

FS="[[:space:]+]"

这个赋值表达式也有问题，它并非必要。为什么？因为缺省情况下，FS 设置成单一空格字符，awk 将这解释成表示“一个或多个空格或 tab”。在这个特殊示例中，缺省 FS 设置恰恰是您最想要的！

复杂的规则表达式也不成问题。即使您的记录由单词 "foo" 分隔，后面跟着三个数字，以下规则表达式仍允许对数据进行正确的分析：

FS="foo[0-9][0-9][0-9]"

字段数量
接着我们要讨论的两个变量通常并不是需要赋值的，而是用来读取以获取关于输入的有用信息。第一个是 NF 变量，也叫做“字段数量”变量。awk 会自动将该变量设置成当前记录中的字段数量。可以使用 NF 变量来只显示某些输入行：

NF == 3 { print "this particular record has three fields: " $0 }

当然，也可以在条件语句中使用 NF 变量，如下：

{   
    if ( NF > 2 ) {
        print $1 " " $2 ":" $3 
    }
}

记录号
记录号 (NR) 是另一个方便的变量。它始终包含当前记录的编号（awk 将第一个记录算作记录号 1）。迄今为止，我们已经处理了每一行包含一个记录的输入文件。对于这些情况，NR 还会告诉您当前行号。然而，当我们在本系列以后部分中开始处理多行记录时，就不会再有这种情况，所以要注意！可以象使用 NF 变量一样使用 NR 来只打印某些输入行：

(NR < 10 ) || (NR > 100) { print "We are on record number 1-9 or 101+" }

另一个示例：

{
    #skip header
    if ( NR > 10 ) {
        print "ok, now for the real information!"
    }
}

awk -v num1=6.6 -v num2=5.5 'BEGIN{print(num1>num2)?"0":"1"}'

 vim:ft=man:
