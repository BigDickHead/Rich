
/* 创建守护进程 */
/*
 *实现守护进程的步骤 
 *1．让init进程成为新产生进程的父进程。 
 *调用fork函数创建子进程后，使父进程立即退出。这样，产生的子进程将变成孤儿进程，并被init进程接管，同时，所产生的新进程将变为在后台运行。 
 *
 *2．调用setsid函数 
 *通过调用setsid函数，使得新创建的进程脱离控制终端，同时创建新的进程组，并成为该进程组的首进程。
 *会话中的进程通过该会话中的领头进程（常称其为控制进程）与一个终端相连。该终端是会话的控制终端。一个会话只能有一个控制终端，反之一样。如果会话存在一个控制终端，则它必然拥有一个前台进程组。属于该组的进程可以从控制终端获得输入。这时，其他的进程组都为后台进程组。
 *由于守护进程没有控制终端，而使用fork函数创建的子进程继承了父进程的控制终端、会话和进程组，因此，必须创建新的会话，以脱离父进程的影响。Linux系统提供了setsid函数用于创建新的会话。
 *setsid函数将创建新的会话，并使得调用setsid函数的进程成为新会话的领头进程。调用setsid函数的进程是新创建会话中的惟一的进程组，进程组ID为调用进程的进程号。setsid函数产生这一结果还有个条件，即调用进程不为一个进程的领头进程。由于在第一步中调用fork的父进程退出，使得子进程不可能是进程组的领头进程。该会话的领头进程没有控制终端与其相连。至此，满足了守护进程没有控制终端的要求。 
 *
 *3．更改当前工作目录 
 *使用fork函数产生的子进程将继承父进程的当前工作目录。当进程没有结束时，其工作目录是不能被卸载的。为了防止这种问题发生，守护进程一般会将其工作目录更改到根目录下（/目录）。更改工作目录使用的函数是chdir。 
 *
 *4．关闭文件描述符，并重定向标准输入、输出和错误输出 
 *新产生的进程从父进程继承了某些打开的文件描述符，如果不使用这些文件描述符，则需要关闭它们。守护进程是运行在系统后台的，不应该在终端有任何的输出信息。可以使用dup函数将标准输入、输出和错误输出重定向到/dev/null设备上（/dev/null是一个空设备，向其写入数据不会有任何输出）。
 *
 *5．设置守护进程的文件权限创建掩码
 */




#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int daemon(int nochdir, int noclose)
{
	pid_t pid;
    pid = fork();
	/* 如果创建进程失败 */
	if (pid < 0) {
		perror("fork");
		return -1;
	}
	/* 父进程退出运行 */
    if (pid != 0)
        exit (0);

	/* 子进程成为会话领头进程 */
	pid = setsid();
	if (pid < -1) {
		perror("setsid");
		return -1;
	}
	/* 将工作目录修改成/ */
	if (!nochdir)
		chdir("/");

	/* 将标准输入输出重定向到空设备 */
	if (!noclose)
    {
		int fd;
		fd = open("/dev/null", O_RDWR, 0);

		if (fd != -1)
        {
			dup2(fd, STDIN_FILENO);
			dup2(fd, STDOUT_FILENO);
			dup2(fd, STDERR_FILENO);
			if (fd > 2)
				close(fd);
		}
	}

    //通常情况下，守护进程会常见一些临时文件，出于安全性考虑，往往不希望这些文件被其他用户查看，所以umask(0027);
    umask(0027);
	return 0;
}


int main(int argc, const char *argv[])
{
    daemon(0, 0);
    sleep(1000);

    return 0;
}
